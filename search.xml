<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Weex! This is for everyone]]></title>
    <url>%2F2018%2F03%2F06%2Fweex-for-everyone%2F</url>
    <content type="text"><![CDATA[Weex，一个让我神往已久的技术。终于到了可以谈一谈的地步。接触weex5天了，坑踩了不少，差不多可以算入门了吧！正式说它之前先谈谈web吧！ 前言web开发技术完全可以说是人类历史上的大量优秀科学家、工程师理论与实践的结果，特别能体现互联网精神：共享、开放。它自诞生之日起，就担负着传播人类文化知识的重任。可以说，web完全不输于人类历史上那些响当当的重要发明，比如：蒸汽机、电灯、智能手机。 如果说，我崇拜谁呢，就蒂姆·伯纳斯·李绝对算一个。当初看央视的纪录片《互联网时代》，一个场面让我叹为观止：蒂姆·伯纳斯·李在2012年当你编写世界上第一个web服务器和客户端的电脑上敲出“This is for everyone”。 太帅了！ 为什么是Weex？web开放包容、跨平台的特性，带来了互联网的繁荣，但它也有天生的缺点： 各浏览器厂商对JS标准的实现不同，导致了兼容性问题； 每次打开网页需要去远程下载，天然地慢一拍； DOM设计的缺陷，每次更新页面浏览器需要进行大量的操作。 在移动互联时代，第一个问题已不那么明显。后两个问题，无法根治。只能不断优化，对于第二个问题一般是采取减小请求数、缓存的机制；对于最后一个问题，现在比较流行的做法是Facebook最早在React中运用的虚拟DOM，还有通过SVG图的方式。 而移动互联时代绝对主角——原生应用，它安装在本地，直接运行在系统中，具有高性能，那它有什么缺点呢？主要有二： 平台差异：同一产品一般至少需要开发web、android、ios三端，需要三波开发团队； 上线周期慢：一款应用上线一般需要一到几周，而这对时机稍纵即逝的互联网圈基本是不能容忍的。 如果有一个解决方案具有web跨平台、社区繁荣的优点，又兼备原生应用的高性能就好了。 今天的主角该出场了：Weex们。 闪亮登场Weex们，是社区中诞生的使用web开发过程开发端应用的技术。 通俗说，就是写一套web前端代码，编译成web、android、ios三端都可用的应用。 之所以加“们”，是因为除了Weex，社区还有现在最流行的React Native。 一探究竟我在原来学习Vue时做的项目中，选了个难度适中的来做weex重构。 效果 项目源码：weex-eleme 名存实亡的标签weex中，基本上可以说没有标签一说。 weex只支持一组内置的组件和在内置组件的基础上自定义的组件。 如果你要写一个weex，首先要做的就是把原来习惯的所有文本相关的标签换成&lt;text&gt;，图片相关的换成&lt;image&gt;。 CSS的差异weex中只支持单个类名，不允许使用关系选择器来定义类名。这一点官方文档里并没有说，但确是网友们踩坑总结出来的经验。 123456789// 单个类名，允许.a &#123; color: #fff; &#125;// 关系选择器，无效.a .b &#123; color: #000;&#125; 社区里有人成功地通过安装开发依赖和配置webpack的module选项使用了向sass这样的样式预处理器，也有说weex集成了常用的几种css预处理器，直接使用下面这样的标签写样式就行： 1&lt;style lang=&quot;sass&quot; scope&gt; 动态绑定类名在Vue中，我们通常像下面这样动态绑定类名： 12// 在weex中，类名可以成功加到渲染后的标签属性中，但样式不起作用&lt;div class=&quot;nav&quot; :class=&quot;&#123;active: flag&#125;&quot;&gt;&lt;/div&gt; 这是个比较奇怪的坑，最后找到一个解决方案： 12// 使用数组语法，数组里可以是三目运算或者函数调用&lt;div class=&quot;nav&quot; :class=&quot;[flag?&apos;active&apos;:&apos;&apos;]&quot;&gt;&lt;/div&gt; 元素内联weex中，&lt;text&gt;会被渲染成&lt;p&gt;，&lt;image&gt;会被渲染出&lt;figure&gt;，所有的display属性无法使用。如果你需要达到元素内联的效果，那你可以使用FlexBox： 12345678910111213 &lt;div class=&quot;wrapper&quot;&gt; &lt;text&gt;some text&lt;/text&gt; // image必须设置宽高 &lt;image style=&quot;width: 300;height: 300;border-width:2px;&quot; src=&quot;https://cn.vuejs.org/images/logo.png1 &gt; &lt;/image&gt; &lt;/div&gt;.wrapper &#123; flex-direction: row; &#125; scroller、list组件的坑weex提供了一个高效的适合显示长列表的&lt;list&gt;组件。它在加载包含大量图片的场景下威力就发挥出来了。 它初始时只会加载首屏的图片，在快滚到底部时再去请求新的图片。但，你必须给&lt;list&gt;（或者&lt;scroller&gt;）设置一个高度（水平使用时设置宽度）。 这个坑我是深有感受，没有给&lt;list&gt;设置高度，你滚动时&lt;list&gt;总是也到不了底部，下部的图片时不会加载的，而且scrollElement方法是不会奏效的。 如图所示，你设置的是wrapper的高度，wrapper不动，而content长度是超出wrapper的，你滚动时其实只是content在相对wrapper变化。只有这样，才能获取content相对于wrapper的位置，进行loadmore、scrollElement等事件或方法。 不然，wrapper的高度是被content撑开的，那它们就一起滚动了。 文本截断在官方的示例中，可以给&lt;text&gt;设置lines属性限制文本的行数： 其中有一个错误，就是lines设置再标签上是没有用的，只有通过类名指定才会起效。 然而，我电脑上并没有什么用！囧。 如果你的电脑也不起效，你可以向下面这样： 12345678910&lt;text class=&quot;text&quot;&gt; some text some text some text some text some text some text&lt;/text&gt;.text &#123; // 设置在css里，不一定起效 lines: 1 // 替代方案，官方示例渲染后的真实属性 -webkit-line-clapm: 1;&#125; 占坑bug常有，坑常有，来日填。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>weex</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Albert Music穿上React新衣——记一次Vue项目重构经历]]></title>
    <url>%2F2018%2F02%2F28%2Freact-meet-vue%2F</url>
    <content type="text"><![CDATA[React的学习曲线高早有耳闻，但真的只有切身经历后才感受的深，也渐渐明白了Vue“渐进式框架”定位的含义。初学React时，只是使用了Ant Design搭积木式做了个新闻webApp，离掌握还差得远。于是，就有了这个React版Albert Music。 技术栈框架：React 16脚手架：Create-React-App路由：React Router 4数据管理：Redux 3数据请求：axios、jsonp优化：immutable.js、fastclick、AsyncComponent实现按需加载动画：React Transition Group语言：ES6预处理：Less 效果 脱坑要不要npm run eject？Create-React-App据说是为了优雅，将webpack配置相关的文件封装进了react-scripts包中。这有助于让开发者专注于前端代码，但却束缚力我们的手脚，不利于在脚手架的基础上进行扩展。我选择的是将配置文件暴露出来。 对webpack配置文件，主要进行三方面改造： 设置文件路径别名 使用less-loader 基于Express，通过devServer里before(app)函数设置数据接口 项目结构的选择以下两种项目结构或许都行：第一种，我现在使用的1234567891011121314151617181920|── src| |── api # 接口相关| |── base #基础组件| |── common # 通用文件| | |── fonts # 字体、图标| | |── images # 图片资源| | |── js # 函数| | |── style # 样式| |──components # 业务组件| |──store # Redux配置| | |── reducers # reducer文件夹| | | |── a.js # 子Reducer| | | |── b.js # 子Reducer| | | |── index.js # 合成所有子Reducer| | |── action-types.js # Action类型汇总| | |── actions.js # 定义action生成器、派发action| | |── index.js # 创建store| |──App.js # 根组件| |──index.js # 入口文件，根组件挂载| |──registerServiceWorker.js 第二种，Redux官方例子的项目目录 12345678910111213141516171819202122|── src| |──actions # Redux的Action文件夹| | |── actions.js # 定义action生成器、派发action| |── api # 接口相关| |── base #基础组件| |── common # 通用文件| | |── fonts # 字体、图标| | |── images # 图片资源| | |── js # 函数| | |── style # 样式| |──components # UI组件| |──constants # 常量| | |── action-types.js # Action类型汇总| |──containers # 容器组件| |──store # Redux配置| |── reducers # Redux的Reducer文件夹| | |── a.js # 子Reducer| | |── b.js # 子Reducer| | |── index.js # 合成所有子Reducer| |──App.js # 根组件| |──index.js # 入口文件，根组件挂载，创建store| |──registerServiceWorker.js 这两种项目结构主要有两点差别： 第一种统一将Redux放在src下，而第二种将Redux拆分后各部分直接放在src下 后者将使用了Redux的组件显式拆分成UI组件和容器组件，层次清晰 第一种有着明显的Vue全家桶开发痕迹，但整个技术栈的层次清晰。第二种更适合React全家桶的开发模式，显式将使用了Redux的组件拆分，这点有着明显的优点。 或许，结合两者的优点是更好的选择：将Redux相关的写到一个文件，显式写出容器组件 路由配置在Vue中，我们习惯于通过一个配置文件t统一管理路由，像这样： 12345678910111213141516171819export default new Router(&#123; mode: 'history', routes: [ &#123; path: '/', redirect: '/recommend' &#125;, &#123; path: '/recommend', component: Recommend, children: [ &#123; path: ':id', component: Disc &#125; ] &#125; ]&#125;) 而在React中，路由也是组件。需要像下面这样把根组件App改造成一个Router组件。至于子路由，可以直接在这个文件配置，也可以在需要的组件下再嵌套 123456789101112131415161718192021// App.jsclass App extends Component &#123; render() &#123; return ( &lt;Router&gt; &lt;Switch&gt; &lt;Route path="/" exact render=&#123;() =&gt; ( &lt;Redirect to="/recommend" /&gt; )&#125; /&gt; &lt;Route path="/recommend" component=&#123;Recommend&#125; /&gt; &lt;/Switch&gt; &lt;/Router&gt; ); &#125;&#125;// Recommend.jsexport const Recommend = (&#123;match&#125;) =&gt; (&#123; &lt;Route path=&#123;`$&#123;match.url&#125;/:Id`&#125; component=&#123;SingerDetail&#125; /&gt; &lt;Route exact path=&#123;match.url&#125; render=&#123;() =&gt; SomeComp /&gt;&#125;) 监听数据变化这个大概是两个框架的最大差别了。 在Vue中，我们可以很方便地设置计算属性和watch来处理数据变化时的逻辑。 在React中，为达到同样的目的，我使用了shouldComponentUpdate()、componentWillReceiveProps()这两个钩子函数。123456789101112shouldComponentUpdate(nextProps, nextState) &#123; // 监测state变化 if (nextStates.foo !== nextState.foo) &#123; // doSomething &#125;&#125;componentWillReceiveProps(nextProps) &#123; // 监测props变化 if (nextProps.baz !== nextProps.baz) &#123; // doSomething &#125;&#125; 列表和条件渲染在Vue中，列表和条件渲染可以方便的分别通过v-for、v-if或者v-show来实现。 在React中，我们需要采用jsx的方式： 12345678910111213// 列表渲染const listItems = &#123; // key是必须的，有助于提升重新渲染时的性能 array.map((item, index) =&gt; ( &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;/li&gt; &#125;ReactDOM.render( &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;, document.getElementById('root'));// 条件渲染const UserCenter = this.props.isLogIn ? : &lt;LogOut /&gt; : &lt;LogIn /&gt; 数据管理Vue有Vuex，React对应着Redux。不过，Redux比Vuex使用起来复杂得多。 四句话就能说请Vuex的用法： 1、设置state对象：里面包含所有需要全局管理的数据2、设置mutation-types：一个数据对应一个类型，如：1export const SET_DATA='SET_DATA' 3、设置mutation：一个mutation改变一个state里的数据，仅赋值4、设置action：每个action可包含复杂逻辑、异步请求，通过commit提交mutation一个或多个请求 Redux就复杂多了，又是中间件、又是react-redux，不过我经过多天的爬坑也可提炼个基本套路： 1、设置action-types：一个数据对应一个类型，如：1export const SET_DATA='SET_DATA' 2、编写Actions.js：一个数据对应一个Action生成器，为每个Action编写一个函数派发它，最后编写派发多个action的函数3、编写Reducer文件夹：index.js，负责合成子Reducer，并提供state里所有数据的接口；若干个子Reducer，为接受每个Action更新state里的对应数据4、设置store：传入将合成后的Reducer、中间件5、拆分组件：将需要使用全局数据的组件用一个空组件包裹，将Redux的数据接口提供给mapStateToProps，actions提供给mapDispatchToProps，通过connect将外层组件变为容器组件，给内层组件传入属性、方法 终于赶在了3月前把项目重构完，也算是把React全家桶掌握了。下一站，Weex！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遇见webpack]]></title>
    <url>%2F2018%2F01%2F30%2Fhello-webpack%2F</url>
    <content type="text"><![CDATA[Webpack很早就接触了，但以前一直都是跟着脚手架跑跑命令行。配置文件也不算陌生，但一直也没深究。毕竟webpack配置工程师可是稀缺人才啊！昨天在微博上看到有人把阮一峰的webpack-demos教程更新到了3.1，但只有英文版。我索性做个中文文档，趁此再系统学习学习。 这里收集了一些Webpack的简单demo。 我旨在通过简明的方式来写这些demo。跟着它们，你将轻松地学习这一强大的工具。 如何使用首先，全局安装Webpack and webpack-dev-server 1$ npm i -g webpack webpack-dev-server 之后，复制这个库到本地。 1$ git clone https://github.com/ruanyf/webpack-demos.git 接着，安装所有依赖。 12$ cd webpack-demos$ npm install 现在，按顺序在这些以demo开头的目录下运行源文件。像这样： 12$ cd demo01$ npm run dev 如果以上命令没有自动打开你的浏览器，恐怕你需要自行访问http://127.0.0.1:8080 。 前言：Webpack是什么Webpack是一个为浏览器构建JavaScript模块脚本的前端工具。 它用起来和Browserify很像，但功能更强大。 123$ browserify main.js &gt; bundle.js# 等同于$ webpack main.js bundle.js Webpack需要一个叫做webpack.config.js配置文件，而它其实就是一个CommonJS文件。 1234567// webpack.config.jsmodule.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;&#125;; 在配置好webpack.config.js文件后，你能在没有任何参数的情况下启动webpack。 1$ webpack Some command-line options you should know.下面这些命令行选项你需要知道： webpack – 开发环境下打包 webpack -p – 生产环境下打包 (压缩) webpack --watch – 监听文件变化并自动打包 webpack -d – 包含source maps（译注：source maps为源码转化后的位置信息文件） webpack --colors – 生成带有颜色的打包输出信息 你可以像下面这样在你的package.json文件中自定义scripts项。 123456789// package.json&#123; // ... "scripts": &#123; "dev": "webpack-dev-server --devtool eval --progress --colors", "deploy": "NODE_ENV=production webpack -p" &#125;, // ...&#125; 目录 入口文件 多个入口文件 Babel-loader CSS-loader Image loader CSS模块 UglifyJs插件 HTML Webpack插件和Open Browser Webpack插件 环境标志 代码分割 使用bundle-loader进行代码分割 共同块 依赖块 暴露全局变量 React router Demo01: 入口文件 (源码)Webpack读取入口文件来生成bundle.js。 例如，main.js就是这样一个入口文件。 12// main.jsdocument.write('&lt;h1&gt;Hello World&lt;/h1&gt;'); index.html 12345&lt;html&gt; &lt;body&gt; &lt;script type="text/javascript" src="bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Webpack按照webpack.config.js里的配置来生成bundle.js。 1234567// webpack.config.jsmodule.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;&#125;; 启动webpack server，访问http://127.0.0.1:8080 。 12$ cd demo01$ npm run dev Demo02: 多个入口文件 (源码)有多个入口文件也是允许的。对于有多个不同入口文件的多页应用来说这会很有用。 12345// main1.jsdocument.write('&lt;h1&gt;Hello World&lt;/h1&gt;');// main2.jsdocument.write('&lt;h2&gt;Hello Webpack&lt;/h2&gt;'); index.html 123456&lt;html&gt; &lt;body&gt; &lt;script src="bundle1.js"&gt;&lt;/script&gt; &lt;script src="bundle2.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; webpack.config.js 123456789module.exports = &#123; entry: &#123; bundle1: './main1.js', bundle2: './main2.js' &#125;, output: &#123; filename: '[name].js' &#125;&#125;; Demo03: Babel-loader (源码)xxx-loader(more info 是在Webpack打包前转换项目里资源文件的预处理器。 例如，Babel-loader能够将JSX/ES6文件转换成普通的JS文件，之后，Webpack再打包它们。Webpack的官方文档里列出了完整的loaders。 main.jsx是一个JSX文件。 12345678// main.jsxconst React = require('react');const ReactDOM = require('react-dom');ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.querySelector('#wrapper')); index.html 123456&lt;html&gt; &lt;body&gt; &lt;div id="wrapper"&gt;&lt;/div&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; webpack.config.js 1234567891011121314151617181920module.exports = &#123; entry: './main.jsx', output: &#123; filename: 'bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\.jsx?$/, exclude: /node_modules/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['es2015', 'react'] &#125; &#125; &#125; ] &#125;&#125;; 以上代码在使用babel-loader时，需要Babel的预设插件babel-preset-es2015和babel-preset-react来转换ES6和React。 Demo04: CSS-loader (源码)Webpack允许你在JS文件中包含CSS，它将通过CSS-loader来预处理这些CSS。 main.js 1require('./app.css'); app.css 123body &#123; background-color: blue;&#125; index.html 12345678&lt;html&gt; &lt;head&gt; &lt;script type="text/javascript" src="bundle.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; webpack.config.js 1234567891011121314module.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;, module: &#123; rules:[ &#123; test: /\.css$/, use: [ 'style-loader', 'css-loader' ] &#125;, ] &#125;&#125;; 注意，你需要两个loader来转换CSS文件。一个是CSS-loader来读CSS文件，另一个是Style-loader来将&lt;style&gt;标签插入HTML页面中。 之后，启动webpack server。 12$ cd demo04$ npm run dev 其实，Webpack将内联样式表插入了index.html。 12345678&lt;head&gt; &lt;script type="text/javascript" src="bundle.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; body &#123; background-color: blue; &#125; &lt;/style&gt;&lt;/head&gt; Demo05: Image loader (源码)Webpack也能在JS文件包含图片。 main.js 1234567var img1 = document.createElement("img");img1.src = require("./small.png");document.body.appendChild(img1);var img2 = document.createElement("img");img2.src = require("./big.png");document.body.appendChild(img2); index.html 12345&lt;html&gt; &lt;body&gt; &lt;script type="text/javascript" src="bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; webpack.config.js 123456789101112131415161718192021module.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;, module: &#123; rules:[ &#123; test: /\.(png|jpg)$/, use: [ &#123; loader: 'url-loader', options: &#123; limit: 8192 &#125; &#125; ] &#125; ] &#125;&#125;; url-loader将图片文件转换成&lt;img&gt;标签。如果图片尺寸小于8192字节，它会被转换成Data URL（译注：Data URL是将图片用base64编码后的字符串）；否则，它将转换成普通URL。 在启动server后，small.png和big.png分别将有以下URL： 12&lt;img src="data:image/png;base64,iVBOR...uQmCC"&gt;&lt;img src="4853ca667a2b8b8844eb2693ac1b2578.png"&gt; Demo06: CSS模块 (源码)带查询参数modules的css-loader将CSS文件变为一个CSS模块，模块里的CSS都是局部定义的。你可以使用:global(selector)(详情)将CSS变为全局的。 index.html 12345678&lt;html&gt;&lt;body&gt; &lt;h1 class="h1"&gt;Hello World&lt;/h1&gt; &lt;h2 class="h2"&gt;Hello Webpack&lt;/h2&gt; &lt;div id="example"&gt;&lt;/div&gt; &lt;script src="./bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; app.css 123456789/* local scope */.h1 &#123; color:red;&#125;/* global scope */:global(.h2) &#123; color: blue;&#125; main.jsx 1234567891011var React = require('react');var ReactDOM = require('react-dom');var style = require('./app.css');ReactDOM.render( &lt;div&gt; &lt;h1 className=&#123;style.h1&#125;&gt;Hello World&lt;/h1&gt; &lt;h2 className="h2"&gt;Hello Webpack&lt;/h2&gt; &lt;/div&gt;, document.getElementById('example')); webpack.config.js 12345678910111213141516171819202122232425262728293031323334module.exports = &#123; entry: './main.jsx', output: &#123; filename: 'bundle.js' &#125;, module: &#123; rules:[ &#123; test: /\.js[x]?$/, exclude: /node_modules/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['es2015', 'react'] &#125; &#125; &#125;, &#123; test: /\.css$/, use: [ &#123; loader: 'style-loader' &#125;, &#123; loader: 'css-loader', options: &#123; modules: true &#125; &#125; ] &#125; ] &#125;&#125;; 启动webpack server。 12$ cd demo06$ npm run dev 访问http://127.0.0.1:8080 ，你将发现只有第二个h1是红色的，因为它的CSS是局部的；而两个h2都是蓝色的，因为它的CSS是全局的。 Demo07: UglifyJs插件 (源码)Webpack通过插件体系来扩展它的功能。例如，UglifyJs插件能够压缩输出(bundle.js)的JS代码。 main.js 123var longVariableName = 'Hello';longVariableName += ' World';document.write('&lt;h1&gt;' + longVariableName + '&lt;/h1&gt;'); index.html 12345&lt;html&gt;&lt;body&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; webpack.config.js 123456789101112var webpack = require('webpack');var UglifyJsPlugin = require('uglifyjs-webpack-plugin');module.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;, plugins: [ new UglifyJsPlugin() ]&#125;; 在启动server之后，main.js将会被压缩成下面这样。 1var o="Hello";o+=" World",document.write("&lt;h1&gt;"+o+"&lt;/h1&gt;") Demo08: HTML Webpack插件和Open Browser Webpack插件 (源码)这个demo像你演示如何载入第三方插件。 html-webpack-plugin能够为你创建index.html，而open-browser-webpack-plugin当Webpack载入时能够打开一个新的浏览器标签页。 main.js 1document.write('&lt;h1&gt;Hello World&lt;/h1&gt;'); webpack.config.js 123456789101112131415161718var HtmlwebpackPlugin = require('html-webpack-plugin');var OpenBrowserPlugin = require('open-browser-webpack-plugin');module.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;, plugins: [ new HtmlwebpackPlugin(&#123; title: 'Webpack-demos', filename: 'index.html' &#125;), new OpenBrowserPlugin(&#123; url: 'http://localhost:8080' &#125;) ]&#125;; 启动server。 12$ cd demo08$ npm run dev 现在你不必再手写index.html了，也不必再自己打开浏览器了。Webpack将会为你做这些事。 Demo09: 环境标志 (源码)你可以通过环境标志让某些代码仅在开发环境下有效。 main.js 12345document.write('&lt;h1&gt;Hello World&lt;/h1&gt;');if (__DEV__) &#123; document.write(new Date());&#125; index.html 12345&lt;html&gt;&lt;body&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; webpack.config.js 12345678910111213var webpack = require('webpack');var devFlagPlugin = new webpack.DefinePlugin(&#123; __DEV__: JSON.stringify(JSON.parse(process.env.DEBUG || 'false'))&#125;);module.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;, plugins: [devFlagPlugin]&#125;; 现在把环境变量传递给webpack。打开demo09/package.json，你应该会发现scripts变成了这样： 12345678// package.json&#123; // ... "scripts": &#123; "dev": "cross-env DEBUG=true webpack-dev-server --open", &#125;, // ...&#125; 启动server。 12$ cd demo09$ npm run dev Demo10: 代码分割 (源码)对于大型web应用来说，将所有的代码写进一个文件效率会很低。Webpack允许你将大的JS文件拆分成若干个小的代码块（chunk)。尤其在一些代码块仅在某些情况下才使用时，这些代码块应该按需加载。 Webpack使用require.ensure去定义一个拆分点(官方文档)。 1234567// main.jsrequire.ensure(['./a'], function (require) &#123; var content = require('./a'); document.open(); document.write('&lt;h1&gt;' + content + '&lt;/h1&gt;'); document.close();&#125;); require.ensure告诉Webpack./a.js应该从bundle.js中分离出来，并打包成一个单独的块文件。 12// a.jsmodule.exports = 'Hello World'; 现在Webpack将会关心依赖、输出文件和运行时环境。而你不必往index.html和webpack.config.js里添加任何东西。 12345&lt;html&gt; &lt;body&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; webpack.config.js 123456module.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;&#125;; 启动server。 12$ cd demo10$ npm run dev 表面上，你不会感觉到任何变化。然而，Webpack实际上将main.js和a.js打包成了不同的块（bundle.js和0.bundle.js)，并且在需要时从bundle.js载入0.bundle.js。 Demo11: 使用bundle-loader进行代码分割 (源码)另一种代码分割的方式是使用bundle-loader。 123456789101112// main.js// 现在导入请求a.js，将它打包进另一个文件var load = require('bundle-loader!./a.js');// 等待a.js载入并获得它导出的内容// 你需要异步等待它load(function(file) &#123; document.open(); document.write('&lt;h1&gt;' + file + '&lt;/h1&gt;'); document.close();&#125;); require(&#39;bundle-loader!./a.js&#39;)告诉Webpack从另一个块中载入a.js。 现在Webpack将会把main.js打包成bundle.js，把a.js打包成0.bundle.js。 Demo12: 共同块 (源码)当多个脚本有共同的代码块时，你可以用CommonsChunkPlugin将它们导入一个单独的文件，这有助于浏览器缓存以及节省带宽。 1234567891011121314151617// main1.jsxvar React = require('react');var ReactDOM = require('react-dom');ReactDOM.render( &lt;h1&gt;Hello World&lt;/h1&gt;, document.getElementById('a'));// main2.jsxvar React = require('react');var ReactDOM = require('react-dom');ReactDOM.render( &lt;h2&gt;Hello Webpack&lt;/h2&gt;, document.getElementById('b')); index.html 123456789&lt;html&gt; &lt;body&gt; &lt;div id="a"&gt;&lt;/div&gt; &lt;div id="b"&gt;&lt;/div&gt; &lt;script src="commons.js"&gt;&lt;/script&gt; &lt;script src="bundle1.js"&gt;&lt;/script&gt; &lt;script src="bundle2.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 以上的commons.js是main1.jsx和main2.jsx的共同代码块。正如所料，commons.js包含了react和react-dom。 webpack.config.js 12345678910111213141516171819202122232425262728293031323334var webpack = require('webpack');module.exports = &#123; entry: &#123; bundle1: './main1.jsx', bundle2: './main2.jsx' &#125;, output: &#123; filename: '[name].js' &#125;, module: &#123; rules:[ &#123; test: /\.js[x]?$/, exclude: /node_modules/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['es2015', 'react'] &#125; &#125; &#125;, ] &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: "commons", // （共同块的名称） filename: "commons.js", // （共同块的文件名） &#125;) ]&#125; Demo13: 依赖块 (源码)通过CommonsChunkPlugin，你也能将依赖库从脚本中导入一个单独的文件。 main.js 12var $ = require('jquery');$('h1').text('Hello World'); index.html 1234567&lt;html&gt; &lt;body&gt; &lt;h1&gt;&lt;/h1&gt; &lt;script src="vendor.js"&gt;&lt;/script&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; webpack.config.js 1234567891011121314151617var webpack = require('webpack');module.exports = &#123; entry: &#123; app: './main.js', vendor: ['jquery'], &#125;, output: &#123; filename: 'bundle.js' &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', filename: 'vendor.js' &#125;) ]&#125;; 上面的代码中，entry.vendor: [&#39;jquery&#39;]告诉Webpack应该将jquery包含在共同的代码块vendor.js中。 如果你想一个模块变量全局生效，例如不通过require(&quot;jquery&quot;)就在每一个模块中使用$和jQuery。你应该使用ProvidePlugin (官方文档)，它能不用特意引入而自动载入模块。 123456789101112131415161718192021// main.js$('h1').text('Hello World');// webpack.config.jsvar webpack = require('webpack');module.exports = &#123; entry: &#123; app: './main.js' &#125;, output: &#123; filename: 'bundle.js' &#125;, plugins: [ new webpack.ProvidePlugin(&#123; $: 'jquery', jQuery: 'jquery' &#125;) ]&#125;; 当然，在这个例子中，你应该自己全局导入jquery.js。 Demo14: 暴露全局变量 (源码)If you want to use some global variables, and don’t want to include them in the Webpack bundle, you can enable externals field in webpack.config.js (official document). 例如，我们有一个data.js。 12// data.jsvar data = 'Hello World'; index.html 123456&lt;html&gt; &lt;body&gt; &lt;script src="data.js"&gt;&lt;/script&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 注意，Webpack只会生成bundle.js，而不会生成data.js。 我们可以将data暴露为一个全局变量。 12345678910111213141516171819202122232425// webpack.config.jsmodule.exports = &#123; entry: './main.jsx', output: &#123; filename: 'bundle.js' &#125;, module: &#123; rules:[ &#123; test: /\.js[x]?$/, exclude: /node_modules/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['es2015', 'react'] &#125; &#125; &#125;, ] &#125;, externals: &#123; // 通过require('data')导入data.js即可全局生效 'data': 'data' &#125;&#125;; 现在，你在脚本里像模块变量一样导入data，但实际上它是一个全局变量。 123456789// main.jsxvar data = require('data');var React = require('react');var ReactDOM = require('react-dom');ReactDOM.render( &lt;h1&gt;&#123;data&#125;&lt;/h1&gt;, document.body); 你也能将react和react-dom放入externals里，这将极大地减小bundle.js的编译时间和大小。 Demo15: React router (源码)这个demo使用webpack来构建React-router的官方例子。 想象一个有着仪表板、收信箱和日历的小应用。 12345678910111213141516171819+---------------------------------------------------------+| +---------+ +-------+ +--------+ || |Dashboard| | Inbox | |Calendar| Logged in as Jane || +---------+ +-------+ +--------+ |+---------------------------------------------------------+| || Dashboard || || || +---------------------+ +----------------------+ || | | | | || | + + | +---------&gt; | || | | | | | | || | | + | | +-------------&gt; | || | | | + | | | | || | | | | | | | | || +-+---+----+-----+----+ +----------------------+ || |+---------------------------------------------------------+ webpack.config.js 123456789101112131415161718192021222324module.exports = &#123; entry: './index.js', output: &#123; filename: 'bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\.css$/, use: [ 'style-loader', 'css-loader' ] &#125;, &#123; test: /\.jsx?$/, exclude: /node_modules/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['es2015', 'react'] &#125; &#125; &#125;, ] &#125;&#125;; index.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import React from 'react';import &#123; render &#125; from 'react-dom';import &#123; BrowserRouter, Switch, Route, Link &#125; from 'react-router-dom';import './app.css';class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;header&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to="/app"&gt;Dashboard&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to="/inbox"&gt;Inbox&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to="/calendar"&gt;Calendar&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; Logged in as Jane &lt;/header&gt; &lt;main&gt; &lt;Switch&gt; &lt;Route exact path="/" component=&#123;Dashboard&#125;/&gt; &lt;Route path="/app" component=&#123;Dashboard&#125;/&gt; &lt;Route path="/inbox" component=&#123;Inbox&#125;/&gt; &lt;Route path="/calendar" component=&#123;Calendar&#125;/&gt; &lt;Route path="*" component=&#123;Dashboard&#125;/&gt; &lt;/Switch&gt; &lt;/main&gt; &lt;/div&gt; ); &#125;&#125;;class Dashboard extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;p&gt;Dashboard&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;;class Inbox extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;p&gt;Inbox&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;;class Calendar extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;p&gt;Calendar&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;;render(( &lt;BrowserRouter&gt; &lt;Route path="/" component=&#123;App&#125; /&gt; &lt;/BrowserRouter&gt;), document.querySelector('#app')); index.html 123456&lt;html&gt; &lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;script src="/bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/htmL&gt; 启动server。 12$ cd demo15$ npm run dev 有用的链接 Webpack docs webpack-howto, by Pete Hunt SurviveJS Webpack book, by Juho Vepsäläinen Diving into Webpack, by Web Design Weekly Webpack and React is awesome, by Christian Alfoni Browserify vs Webpack, by Cory House 许可证MIT]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[indexOf()引发的血案——引用类型初探]]></title>
    <url>%2F2018%2F01%2F23%2Funderstand-reference-type%2F</url>
    <content type="text"><![CDATA[最近，又开始学JS了。JS大概永远也学不完吧！ 初学时，选择的是“犀牛书”，它被称为JS程序员心中的“圣经”。被称为“经”，我想是有原因的。这本书块头很大，语言有些晦涩，看得我晕头转向（上次这种感觉还是看《数据结构与算法分析》时），但我竟然啃（fan）下（guo）来（yi）了（bian）。我想很大的原因可能是当初淘宝团队在翻译时采用了接近直译的方式。 后来，发现越来越多的人看的是“红宝书”，那我也不能落下啊！看了几章，相见恨晚。它的语言很对中国人的味儿，就像一位网友说的，读它就像读一篇篇的博客。而它，又不失深度。 案发当我看到第五章引用类型时，被眼前的一幕震惊了： var person = { name: "Nicholas"}; var people = [{ name: "Nicholas"}; var morePeople = [person]; alert(people.indexOf(person)); //-1 alert(morePeople.indexOf(person)); //0 为什么在people中会找不到person，而在morePeople中却可以？ 案情分析1号嫌疑人：印错我买的书虽不一定是正版，但错这么离谱好像不太可能。 无作案动机，排除！ 2号嫌疑人：indexOf()查找时严格相等的条件搜便案发现场，没发现“凶器”类型转换啊？ 有不在场证明，排除！ 僵掉了呀！ 3号嫌疑人：引用类型人脏具获，束手就擒吧： var person = { name: "Nicholas"}; //person是对象{ name: "Nicholas"}的引用A，是一个对象指针 var people = [{ name: "Nicholas"}; //people是一个包含对象{ name: "Nicholas"}的另一个引用B的数组 var morePeople = [person]; //morePeople 是一个包含对象{ name: "Nicholas"}的引用A的数组 alert(people.indexOf(person)); //-1，people中只有引用B，没有引用A alert(morePeople.indexOf(person)); //0，people中有引用A 结案解决每一个问题，都是对自己的查缺补漏。真好！ 基础，基础，基础！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>引用类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F01%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[我在想，你善待世界，大概世界也会善待你吧！ 捣鼓一个星期，总算是把博客搭得差不多了。搭博客的过程简直就是一个踩坑之旅。 博客框架的选择开始之前，在知乎逛了逛，发现搭博客/网站的框架主流的有这么三个： WordPress早闻大名，但是PHP平台的，果断放弃 Hexo基于node，知乎很多人推荐，其中不乏像尤雨溪这样的大神 Hugo基于Go，这一两年火起来的，Github上的star数直逼Hexo。它的定位很是高远，要做世上最快的静态网站生成框架。有网友做过对比说，Hugo的编译速度可以比Hexo快到几十倍 毫无疑问，基于node的Hexo是对搞前端的同学来说最好的选择。 主题重构选主题时的发现，再一次证明了我的选择。 我发现Hexo社区有一款非常棒的主题——next。简直可以用excellent来形容，它好倒不在UI上，那怎么厉害了？ 受欢迎：它在Github上有近1万1的star 生态好：很多网友贡献代码，使得next的功能强大，有详细的文档 配置性好：尽管集成了那么多功能，但通过配置一个config文件，一步搞定 扩展性高：通过swig模板语言编写，方便维护和扩展 可是我对它的UI并不太喜欢，感觉太老土了。于是，我站在巨人的肩上，开始了主题重构。 最后的效果，就是呈现在各位面前的。 我给它取了个名字，叫Memory。 绝地求生“吃鸡”游戏最近很火，我也来蹭下热度。～(￣▽￣～)~ 判断当前页面要实现我的设计，一个首要问题就是判断当前页面的状态，是主页，文章，归档？最后，我在Hexo官方文档找到了答案，嗯，辅助函数：is_home()：检查是否为首页is_post()：检查是否为文章is_archive()：检查是否为归档页… 这些条件函数配合swig之类的模板引擎就能写出你想要的页面逻辑. so nice! 读取页面信息要用siwg写出内容响应式的页面，读取每个页面或文章的具体属性是绕不开的问题。 理论上，读取文章属性，post这个变量最合适不过了。可是，事情总不会那么顺利。 next主题的文档布局是一个大的类名为container的div包裹了header、main、footer三个部分。源码里，文章页的文章内容是包裹在main里面的，而我的需求是将文章的meta信息在header部分显示，而header和main在源码中是在不同模块里实现的，这时用post变量就会出现读取不到值的现象。 这时，又时官方文档拯救了我！我发现，page和post这两个变量有着剪不断理还乱的联系。那就试试page变量！ Did it! 再配合着front-matter，那feel倍爽儿啊！！！可以“从心所欲”了！ 终极bug该来的总会来的。 最后重构的事基本完成了，要部署到Github上了，当我在线访问时，发现我的页面竟然是这样的： Are you kidding me?！！！ 我在本地启server预览时可是OK的！？怎么会public文件夹里的东西和本地server访问的不一样？见鬼了。一套代码，两种编译结果！？ 为此，苦苦挣扎了一天，各种百度，各种看文档，各种问师兄，最后还到hexo仓库下开了个issue。 过了几小时，发现并没有人鸟我。唉，要放弃了。滚去啃转头书了。 越啃越困。。。唉。。。 就在这时，我突然想起了官方文档里提到，对于服务器： 12$ hexo server // 动态监听文件变化$ hexo server -s // 只访问public文件夹里的资源 而对于生成器： 12$ hexo generate // 生成静态文件$ hexo generate -w // 监视文件变动并立即重新生成静态文件 既然hexo s和hexo g的编译结果不一样，而hexo g -w和hexo s同样是动态编译，是不是就可以生成想要的结果呢？ Did it! 写在最后Hello World，大概是每人程序员写的第一个程序了。记得去年阿里18周年年会时，黄龙外就挂着“Hello World”的巨幅喷绘。 我在想，你善待世界，大概世界也会善待你吧！ 这应该算是我第一篇严格意义上的博客了，写博客是进入一个新世界，每一天、每一段旅程都是进入一个新世界。 我常常会跟女朋友讲我在学的、在做的东西，我总试着用最通俗的语言让她也能明白。前段时间，看了一位网友写自己理解闭包的博客，里面有句话让我印象深刻：“如果一个概念你不能用一两句话说明白，那你就是没有真正地懂。” 真是精辟！于是，我计划着写算是一个系列吧，用最通俗、精练的话去总结一些前端的基础问题。一来总结的过程是对自己的提高，为今年的校招做准备，二来要是能对谁有一点帮助那就意外的收获了。 这个系列或许可以叫“前端那些事儿”之类的吧，哈哈！当年明月通俗幽默讲明史，我为何不可通俗幽默说前端呢？ “开机，启动，接入！” 既然选择了远方，便只顾风雨兼程——汪国真]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初次见面，请多指教]]></title>
    <url>%2F2018%2F01%2F18%2Fnice-to-meet-you%2F</url>
    <content type="text"><![CDATA[大家好，你们可以叫我萧文，也可以叫我Albert。 萧文，这个名字和我颇有渊源，小时候就差点叫了这个名字。我在想，以后要是进了哪个厂，我的花名就叫萧文了。 关于我的英文名有个小故事：高中时，英语老师以抽签的方式给每人都取了个英文名，还告诉我Albert有“聪明、高贵、人类的守护者”的意思，我也就阴差阳错地承担起了守护人类、拯救地球的责任。哈哈！ 高考填志愿时，凭着自己多年来练就的“3秒修好掉链条的单车”的天赋，我报了机械专业，自此离拯救地球的道路远走远远。还好，当时学了个C语言程序设计。 本科毕业后，来杭州读了个小硕。没错，还是机械╯▂╰。可是我读的专业是机械和计算机的结合呀，哈哈哈！ 众多CS方向中，我选择了前端。为啥？喜欢呗！我发现这是一个可以将我所有的兴趣都结合起来的。。。 什么呢？ 嗯，事业！！！ 前端太好玩了！什么设计、图形、webGL、动画、游戏、业务、数据可视化、算法，各种新工具、新技术，应有尽有。 有句话叫做：“有人的地方就有江湖。”我想说：“未来的时代，有人的地方就有前端。” 扯了这么多，该滚去学习了。 还有很多知识要学，还有好多代码要写，长路漫漫，任重道远。。。]]></content>
      <categories>
        <category>随想</category>
      </categories>
  </entry>
</search>
