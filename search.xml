<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[遇见webpack]]></title>
    <url>%2F2018%2F01%2F30%2Fhello-webpack%2F</url>
    <content type="text"><![CDATA[Webpack很早就接触了，但以前一直都是跟着脚手架跑跑命令行。配置文件也不算陌生，但一直也没深究。毕竟webpack配置工程师可是稀缺人才啊！昨天在微博上看到有人把阮一峰的webpack-demos教程更新到了3.1，但只有英文版。我索性做个中文文档，趁此再系统学习学习。 这个仓库收集了一些Webpack的简单demo。 我旨在通过简明的方式来写这些demo。跟着它们，你将轻松地学习这一强大的工具。 如何使用首先，全局安装Webpack and webpack-dev-server 1$ npm i -g webpack webpack-dev-server 之后，复制这个库到本地。 1$ git clone https://github.com/ruanyf/webpack-demos.git 接着，安装所有依赖。 12$ cd webpack-demos$ npm install 现在，按顺序在这些以demo开头的目录下运行源文件。像这样： 12$ cd demo01$ npm run dev 如果以上命令没有自动打开你的浏览器，恐怕你需要自行访问http://127.0.0.1:8080 。 前言：Webpack是什么Webpack是一个为浏览器构建JavaScript模块脚本的前端工具。 它用起来和Browserify很像，但功能更强大。 123$ browserify main.js &gt; bundle.js# 等同于$ webpack main.js bundle.js Webpack需要一个叫做webpack.config.js配置文件，而它其实就是一个CommonJS文件。 1234567// webpack.config.jsmodule.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;&#125;; 在配置好webpack.config.js文件后，你能在没有任何参数的情况下启动webpack。 1$ webpack Some command-line options you should know.下面这些命令行选项你需要知道： webpack – 开发环境下打包 webpack -p – 生产环境下打包 (压缩) webpack --watch – 监听文件变化并自动打包 webpack -d – 包含source maps（译注：source maps为源码转化后的位置信息文件） webpack --colors – 生成带有颜色的打包输出信息 你可以像下面这样在你的package.json文件中自定义scripts项。 123456789// package.json&#123; // ... "scripts": &#123; "dev": "webpack-dev-server --devtool eval --progress --colors", "deploy": "NODE_ENV=production webpack -p" &#125;, // ...&#125; 目录 入口文件 多个入口文件 Babel-loader CSS-loader Image loader CSS模块 UglifyJs插件 HTML Webpack插件和Open Browser Webpack插件 环境标志 代码分割 使用bundle-loader进行代码分割 共同块 依赖块 暴露全局变量 React router Demo01: 入口文件 (源码)Webpack读取入口文件来生成bundle.js。 例如，main.js就是这样一个入口文件。 12// main.jsdocument.write('&lt;h1&gt;Hello World&lt;/h1&gt;'); index.html 12345&lt;html&gt; &lt;body&gt; &lt;script type="text/javascript" src="bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Webpack按照webpack.config.js里的配置来生成bundle.js。 1234567// webpack.config.jsmodule.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;&#125;; 启动webpack server，访问http://127.0.0.1:8080 。 12$ cd demo01$ npm run dev Demo02: 多个入口文件 (源码)有多个入口文件也是允许的。对于有多个不同入口文件的多页应用来说这会很有用。 12345// main1.jsdocument.write('&lt;h1&gt;Hello World&lt;/h1&gt;');// main2.jsdocument.write('&lt;h2&gt;Hello Webpack&lt;/h2&gt;'); index.html 123456&lt;html&gt; &lt;body&gt; &lt;script src="bundle1.js"&gt;&lt;/script&gt; &lt;script src="bundle2.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; webpack.config.js 123456789module.exports = &#123; entry: &#123; bundle1: './main1.js', bundle2: './main2.js' &#125;, output: &#123; filename: '[name].js' &#125;&#125;; Demo03: Babel-loader (源码)xxx-loader(more info 是在Webpack打包前转换项目里资源文件的预处理器。 例如，Babel-loader能够将JSX/ES6文件转换成普通的JS文件，之后，Webpack再打包它们。Webpack的官方文档里列出了完整的loaders。 main.jsx是一个JSX文件。 12345678// main.jsxconst React = require('react');const ReactDOM = require('react-dom');ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.querySelector('#wrapper')); index.html 123456&lt;html&gt; &lt;body&gt; &lt;div id="wrapper"&gt;&lt;/div&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; webpack.config.js 1234567891011121314151617181920module.exports = &#123; entry: './main.jsx', output: &#123; filename: 'bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\.jsx?$/, exclude: /node_modules/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['es2015', 'react'] &#125; &#125; &#125; ] &#125;&#125;; 以上代码在使用babel-loader时，需要Babel的预设插件babel-preset-es2015和babel-preset-react来转换ES6和React。 Demo04: CSS-loader (源码)Webpack允许你在JS文件中包含CSS，它将通过CSS-loader来预处理这些CSS。 main.js 1require('./app.css'); app.css 123body &#123; background-color: blue;&#125; index.html 12345678&lt;html&gt; &lt;head&gt; &lt;script type="text/javascript" src="bundle.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; webpack.config.js 1234567891011121314module.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;, module: &#123; rules:[ &#123; test: /\.css$/, use: [ 'style-loader', 'css-loader' ] &#125;, ] &#125;&#125;; 注意，你需要两个loader来转换CSS文件。一个是CSS-loader来读CSS文件，另一个是Style-loader来将&lt;style&gt;标签插入HTML页面中。 之后，启动webpack server。 12$ cd demo04$ npm run dev 其实，Webpack将内联样式表插入了index.html。 12345678&lt;head&gt; &lt;script type="text/javascript" src="bundle.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; body &#123; background-color: blue; &#125; &lt;/style&gt;&lt;/head&gt; Demo05: Image loader (源码)Webpack也能在JS文件包含图片。 main.js 1234567var img1 = document.createElement("img");img1.src = require("./small.png");document.body.appendChild(img1);var img2 = document.createElement("img");img2.src = require("./big.png");document.body.appendChild(img2); index.html 12345&lt;html&gt; &lt;body&gt; &lt;script type="text/javascript" src="bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; webpack.config.js 123456789101112131415161718192021module.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;, module: &#123; rules:[ &#123; test: /\.(png|jpg)$/, use: [ &#123; loader: 'url-loader', options: &#123; limit: 8192 &#125; &#125; ] &#125; ] &#125;&#125;; url-loader将图片文件转换成&lt;img&gt;标签。如果图片尺寸小于8192字节，它会被转换成Data URL（译注：Data URL是将图片用base64编码后的字符串）；否则，它将转换成普通URL。 在启动server后，small.png和big.png分别将有以下URL： 12&lt;img src="data:image/png;base64,iVBOR...uQmCC"&gt;&lt;img src="4853ca667a2b8b8844eb2693ac1b2578.png"&gt; Demo06: CSS模块 (源码)带查询参数modules的css-loader将CSS文件变为一个CSS模块，模块里的CSS都是局部定义的。你可以使用:global(selector)(详情)将CSS变为全局的。 index.html 12345678&lt;html&gt;&lt;body&gt; &lt;h1 class="h1"&gt;Hello World&lt;/h1&gt; &lt;h2 class="h2"&gt;Hello Webpack&lt;/h2&gt; &lt;div id="example"&gt;&lt;/div&gt; &lt;script src="./bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; app.css 123456789/* local scope */.h1 &#123; color:red;&#125;/* global scope */:global(.h2) &#123; color: blue;&#125; main.jsx 1234567891011var React = require('react');var ReactDOM = require('react-dom');var style = require('./app.css');ReactDOM.render( &lt;div&gt; &lt;h1 className=&#123;style.h1&#125;&gt;Hello World&lt;/h1&gt; &lt;h2 className="h2"&gt;Hello Webpack&lt;/h2&gt; &lt;/div&gt;, document.getElementById('example')); webpack.config.js 12345678910111213141516171819202122232425262728293031323334module.exports = &#123; entry: './main.jsx', output: &#123; filename: 'bundle.js' &#125;, module: &#123; rules:[ &#123; test: /\.js[x]?$/, exclude: /node_modules/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['es2015', 'react'] &#125; &#125; &#125;, &#123; test: /\.css$/, use: [ &#123; loader: 'style-loader' &#125;, &#123; loader: 'css-loader', options: &#123; modules: true &#125; &#125; ] &#125; ] &#125;&#125;; 启动webpack server。 12$ cd demo06$ npm run dev 访问http://127.0.0.1:8080 ，你将发现只有第二个h1是红色的，因为它的CSS是局部的；而两个h2都是蓝色的，因为它的CSS是全局的。 Demo07: UglifyJs插件 (源码)Webpack通过插件体系来扩展它的功能。例如，UglifyJs插件能够压缩输出(bundle.js)的JS代码。 main.js 123var longVariableName = 'Hello';longVariableName += ' World';document.write('&lt;h1&gt;' + longVariableName + '&lt;/h1&gt;'); index.html 12345&lt;html&gt;&lt;body&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; webpack.config.js 123456789101112var webpack = require('webpack');var UglifyJsPlugin = require('uglifyjs-webpack-plugin');module.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;, plugins: [ new UglifyJsPlugin() ]&#125;; 在启动server之后，main.js将会被压缩成下面这样。 1var o="Hello";o+=" World",document.write("&lt;h1&gt;"+o+"&lt;/h1&gt;") Demo08: HTML Webpack插件和Open Browser Webpack插件 (源码)这个demo像你演示如何载入第三方插件。 html-webpack-plugin能够为你创建index.html，而open-browser-webpack-plugin当Webpack载入时能够打开一个新的浏览器标签页。 main.js 1document.write('&lt;h1&gt;Hello World&lt;/h1&gt;'); webpack.config.js 123456789101112131415161718var HtmlwebpackPlugin = require('html-webpack-plugin');var OpenBrowserPlugin = require('open-browser-webpack-plugin');module.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;, plugins: [ new HtmlwebpackPlugin(&#123; title: 'Webpack-demos', filename: 'index.html' &#125;), new OpenBrowserPlugin(&#123; url: 'http://localhost:8080' &#125;) ]&#125;; 启动server。 12$ cd demo08$ npm run dev 现在你不必再手写index.html了，也不必再自己打开浏览器了。Webpack将会为你做这些事。 Demo09: 环境标志 (源码)你可以通过环境标志让某些代码仅在开发环境下有效。 main.js 12345document.write('&lt;h1&gt;Hello World&lt;/h1&gt;');if (__DEV__) &#123; document.write(new Date());&#125; index.html 12345&lt;html&gt;&lt;body&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; webpack.config.js 12345678910111213var webpack = require('webpack');var devFlagPlugin = new webpack.DefinePlugin(&#123; __DEV__: JSON.stringify(JSON.parse(process.env.DEBUG || 'false'))&#125;);module.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;, plugins: [devFlagPlugin]&#125;; 现在把环境变量传递给webpack。打开demo09/package.json，你应该会发现scripts变成了这样： 12345678// package.json&#123; // ... "scripts": &#123; "dev": "cross-env DEBUG=true webpack-dev-server --open", &#125;, // ...&#125; 启动server。 12$ cd demo09$ npm run dev Demo10: 代码拆分 (源码)对于大型web应用来说，将所有的代码写进一个文件效率会很低。Webpack允许你将大的JS文件拆分成若干个小的代码块（chunk)。尤其在一些代码块仅在某些情况下才使用时，这些代码块应该按需加载。 Webpack使用require.ensure去定义一个拆分点(官方文档)。 1234567// main.jsrequire.ensure(['./a'], function (require) &#123; var content = require('./a'); document.open(); document.write('&lt;h1&gt;' + content + '&lt;/h1&gt;'); document.close();&#125;); require.ensure告诉Webpack./a.js应该从bundle.js中分离出来，并打包成一个单独的块文件。 12// a.jsmodule.exports = 'Hello World'; 现在Webpack将会关心依赖、输出文件和运行时环境。而你不必往index.html和webpack.config.js里添加任何东西。 12345&lt;html&gt; &lt;body&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; webpack.config.js 123456module.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;&#125;; 启动server。 12$ cd demo10$ npm run dev 表面上，你不会感觉到任何变化。然而，Webpack实际上将main.js和a.js打包成了不同的块（bundle.js和0.bundle.js)，并且在需要时从bundle.js载入0.bundle.js。 Demo11: 使用bundle-loader进行代码分割 (源码)另一种代码分割的方式是使用bundle-loader。 123456789101112// main.js// 现在导入请求a.js，将它打包进另一个文件var load = require('bundle-loader!./a.js');// 等待a.js载入并获得它导出的内容// 你需要异步等待它load(function(file) &#123; document.open(); document.write('&lt;h1&gt;' + file + '&lt;/h1&gt;'); document.close();&#125;); require(&#39;bundle-loader!./a.js&#39;)告诉Webpack从另一个块中载入a.js。 现在Webpack将会把main.js打包成bundle.js，把a.js打包成0.bundle.js。 Demo12: 共同块 (源码)当多个脚本有共同的代码块时，你可以用CommonsChunkPlugin将它们导入一个单独的文件，这有助于浏览器缓存以及节省带宽。 1234567891011121314151617// main1.jsxvar React = require('react');var ReactDOM = require('react-dom');ReactDOM.render( &lt;h1&gt;Hello World&lt;/h1&gt;, document.getElementById('a'));// main2.jsxvar React = require('react');var ReactDOM = require('react-dom');ReactDOM.render( &lt;h2&gt;Hello Webpack&lt;/h2&gt;, document.getElementById('b')); index.html 123456789&lt;html&gt; &lt;body&gt; &lt;div id="a"&gt;&lt;/div&gt; &lt;div id="b"&gt;&lt;/div&gt; &lt;script src="commons.js"&gt;&lt;/script&gt; &lt;script src="bundle1.js"&gt;&lt;/script&gt; &lt;script src="bundle2.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 以上的commons.js是main1.jsx和main2.jsx的共同代码块。正如所料，commons.js包含了react和react-dom。 webpack.config.js 12345678910111213141516171819202122232425262728293031323334var webpack = require('webpack');module.exports = &#123; entry: &#123; bundle1: './main1.jsx', bundle2: './main2.jsx' &#125;, output: &#123; filename: '[name].js' &#125;, module: &#123; rules:[ &#123; test: /\.js[x]?$/, exclude: /node_modules/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['es2015', 'react'] &#125; &#125; &#125;, ] &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: "commons", // （共同块的名称） filename: "commons.js", // （共同块的文件名） &#125;) ]&#125; Demo13: 依赖块 (源码)通过CommonsChunkPlugin，你也能将依赖库从脚本中导入一个单独的文件。 main.js 12var $ = require('jquery');$('h1').text('Hello World'); index.html 1234567&lt;html&gt; &lt;body&gt; &lt;h1&gt;&lt;/h1&gt; &lt;script src="vendor.js"&gt;&lt;/script&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; webpack.config.js 1234567891011121314151617var webpack = require('webpack');module.exports = &#123; entry: &#123; app: './main.js', vendor: ['jquery'], &#125;, output: &#123; filename: 'bundle.js' &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', filename: 'vendor.js' &#125;) ]&#125;; 上面的代码中，entry.vendor: [&#39;jquery&#39;]告诉Webpack应该将jquery包含在共同的代码块vendor.js中。 如果你想一个模块变量全局生效，例如不通过require(&quot;jquery&quot;)就在每一个模块中使用$和jQuery。你应该使用ProvidePlugin (官方文档)，它能不用特意引入而自动载入模块。 123456789101112131415161718192021// main.js$('h1').text('Hello World');// webpack.config.jsvar webpack = require('webpack');module.exports = &#123; entry: &#123; app: './main.js' &#125;, output: &#123; filename: 'bundle.js' &#125;, plugins: [ new webpack.ProvidePlugin(&#123; $: 'jquery', jQuery: 'jquery' &#125;) ]&#125;; 当然，在这个例子中，你应该自己全局导入jquery.js。 Demo14: 暴露全局变量 (源码)If you want to use some global variables, and don’t want to include them in the Webpack bundle, you can enable externals field in webpack.config.js (official document). 例如，我们有一个data.js。 12// data.jsvar data = 'Hello World'; index.html 123456&lt;html&gt; &lt;body&gt; &lt;script src="data.js"&gt;&lt;/script&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 注意，Webpack只会生成bundle.js，而不会生成data.js。 我们可以将data暴露为一个全局变量。 12345678910111213141516171819202122232425// webpack.config.jsmodule.exports = &#123; entry: './main.jsx', output: &#123; filename: 'bundle.js' &#125;, module: &#123; rules:[ &#123; test: /\.js[x]?$/, exclude: /node_modules/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['es2015', 'react'] &#125; &#125; &#125;, ] &#125;, externals: &#123; // 通过require('data')导入data.js即可全局生效 'data': 'data' &#125;&#125;; 现在，你在脚本里像模块变量一样导入data，但实际上它是一个全局变量。 123456789// main.jsxvar data = require('data');var React = require('react');var ReactDOM = require('react-dom');ReactDOM.render( &lt;h1&gt;&#123;data&#125;&lt;/h1&gt;, document.body); 你也能将react和react-dom放入externals里，这将极大地减小bundle.js的编译时间和大小。 Demo15: React router (源码)这个demo使用webpack来构建React-router的官方例子。 想象一个有着仪表板、收信箱和日历的小应用。 12345678910111213141516171819+---------------------------------------------------------+| +---------+ +-------+ +--------+ || |Dashboard| | Inbox | |Calendar| Logged in as Jane || +---------+ +-------+ +--------+ |+---------------------------------------------------------+| || Dashboard || || || +---------------------+ +----------------------+ || | | | | || | + + | +---------&gt; | || | | | | | | || | | + | | +-------------&gt; | || | | | + | | | | || | | | | | | | | || +-+---+----+-----+----+ +----------------------+ || |+---------------------------------------------------------+ webpack.config.js 123456789101112131415161718192021222324module.exports = &#123; entry: './index.js', output: &#123; filename: 'bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\.css$/, use: [ 'style-loader', 'css-loader' ] &#125;, &#123; test: /\.jsx?$/, exclude: /node_modules/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['es2015', 'react'] &#125; &#125; &#125;, ] &#125;&#125;; index.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import React from 'react';import &#123; render &#125; from 'react-dom';import &#123; BrowserRouter, Switch, Route, Link &#125; from 'react-router-dom';import './app.css';class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;header&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to="/app"&gt;Dashboard&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to="/inbox"&gt;Inbox&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to="/calendar"&gt;Calendar&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; Logged in as Jane &lt;/header&gt; &lt;main&gt; &lt;Switch&gt; &lt;Route exact path="/" component=&#123;Dashboard&#125;/&gt; &lt;Route path="/app" component=&#123;Dashboard&#125;/&gt; &lt;Route path="/inbox" component=&#123;Inbox&#125;/&gt; &lt;Route path="/calendar" component=&#123;Calendar&#125;/&gt; &lt;Route path="*" component=&#123;Dashboard&#125;/&gt; &lt;/Switch&gt; &lt;/main&gt; &lt;/div&gt; ); &#125;&#125;;class Dashboard extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;p&gt;Dashboard&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;;class Inbox extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;p&gt;Inbox&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;;class Calendar extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;p&gt;Calendar&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;;render(( &lt;BrowserRouter&gt; &lt;Route path="/" component=&#123;App&#125; /&gt; &lt;/BrowserRouter&gt;), document.querySelector('#app')); index.html 123456&lt;html&gt; &lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;script src="/bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/htmL&gt; 启动server。 12$ cd demo15$ npm run dev 有用的链接 Webpack docs webpack-howto, by Pete Hunt SurviveJS Webpack book, by Juho Vepsäläinen Diving into Webpack, by Web Design Weekly Webpack and React is awesome, by Christian Alfoni Browserify vs Webpack, by Cory House 许可证MIT]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[indexOf()引发的血案——引用类型初探]]></title>
    <url>%2F2018%2F01%2F23%2Funderstand-reference-type%2F</url>
    <content type="text"><![CDATA[最近，又开始学JS了。JS大概永远也学不完吧！ 初学时，选择的是“犀牛书”，它被称为JS程序员心中的“圣经”。被称为“经”，我想是有原因的。这本书块头很大，语言有些晦涩，看得我晕头转向（上次这种感觉还是看《数据结构与算法分析》时），但我竟然啃（fan）下（guo）来（yi）了（bian）。我想很大的原因可能是当初淘宝团队在翻译时采用了接近直译的方式。 后来，发现越来越多的人看的是“红宝书”，那我也不能落下啊！看了几章，相见恨晚。它的语言很对中国人的味儿，就像一位网友说的，读它就像读一篇篇的博客。而它，又不失深度。 案发当我看到第五章引用类型时，被眼前的一幕震惊了： var person = { name: "Nicholas"}; var people = [{ name: "Nicholas"}; var morePeople = [person]; alert(people.indexOf(person)); //-1 alert(morePeople.indexOf(person)); //0 为什么在people中会找不到person，而在morePeople中却可以？ 案情分析1号嫌疑人：印错我买的书虽不一定是正版，但错这么离谱好像不太可能。 无作案动机，排除！ 2号嫌疑人：indexOf()查找时严格相等的条件搜便案发现场，没发现“凶器”类型转换啊？ 有不在场证明，排除！ 僵掉了呀！ 3号嫌疑人：引用类型人脏具获，束手就擒吧： var person = { name: "Nicholas"}; //person是对象{ name: "Nicholas"}的引用A，是一个对象指针 var people = [{ name: "Nicholas"}; //people是一个包含对象{ name: "Nicholas"}的另一个引用B的数组 var morePeople = [person]; //morePeople 是一个包含对象{ name: "Nicholas"}的引用A的数组 alert(people.indexOf(person)); //-1，people中只有引用B，没有引用A alert(morePeople.indexOf(person)); //0，people中有引用A 结案解决每一个问题，都是对自己的查缺补漏。真好！ 基础，基础，基础！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>引用类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F01%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[我在想，你善待世界，大概世界也会善待你吧！ 捣鼓一个星期，总算是把博客搭得差不多了。搭博客的过程简直就是一个踩坑之旅。 博客框架的选择开始之前，在知乎逛了逛，发现搭博客/网站的框架主流的有这么三个： WordPress早闻大名，但是PHP平台的，果断放弃 Hexo基于node，知乎很多人推荐，其中不乏像尤雨溪这样的大神 Hugo基于Go，这一两年火起来的，Github上的star数直逼Hexo。它的定位很是高远，要做世上最快的静态网站生成框架。有网友做过对比说，Hugo的编译速度可以比Hexo快到几十倍 毫无疑问，基于node的Hexo是对搞前端的同学来说最好的选择。 主题重构选主题时的发现，再一次证明了我的选择。 我发现Hexo社区有一款非常棒的主题——next。简直可以用excellent来形容，它好倒不在UI上，那怎么厉害了？ 受欢迎：它在Github上有近1万1的star 生态好：很多网友贡献代码，使得next的功能强大，有详细的文档 配置性好：尽管集成了那么多功能，但通过配置一个config文件，一步搞定 扩展性高：通过swig模板语言编写，方便维护和扩展 可是我对它的UI并不太喜欢，感觉太老土了。于是，我站在巨人的肩上，开始了主题重构。 最后的效果，就是呈现在各位面前的。 我给它取了个名字，叫Memory。 绝地求生“吃鸡”游戏最近很火，我也来蹭下热度。～(￣▽￣～)~ 判断当前页面要实现我的设计，一个首要问题就是判断当前页面的状态，是主页，文章，归档？最后，我在Hexo官方文档找到了答案，嗯，辅助函数：is_home()：检查是否为首页is_post()：检查是否为文章is_archive()：检查是否为归档页… 这些条件函数配合swig之类的模板引擎就能写出你想要的页面逻辑. so nice! 读取页面信息要用siwg写出内容响应式的页面，读取每个页面或文章的具体属性是绕不开的问题。 理论上，读取文章属性，post这个变量最合适不过了。可是，事情总不会那么顺利。 next主题的文档布局是一个大的类名为container的div包裹了header、main、footer三个部分。源码里，文章页的文章内容是包裹在main里面的，而我的需求是将文章的meta信息在header部分显示，而header和main在源码中是在不同模块里实现的，这时用post变量就会出现读取不到值的现象。 这时，又时官方文档拯救了我！我发现，page和post这两个变量有着剪不断理还乱的联系。那就试试page变量！ Did it! 再配合着front-matter，那feel倍爽儿啊！！！可以“从心所欲”了！ 终极bug该来的总会来的。 最后重构的事基本完成了，要部署到Github上了，当我在线访问时，发现我的页面竟然是这样的： Are you kidding me?！！！ 我在本地启server预览时可是OK的！？怎么会public文件夹里的东西和本地server访问的不一样？见鬼了。一套代码，两种编译结果！？ 为此，苦苦挣扎了一天，各种百度，各种看文档，各种问师兄，最后还到hexo仓库下开了个issue。 过了几小时，发现并没有人鸟我。唉，要放弃了。滚去啃转头书了。 越啃越困。。。唉。。。 就在这时，我突然想起了官方文档里提到，对于服务器： 12$ hexo server // 动态监听文件变化$ hexo server -s // 只访问public文件夹里的资源 而对于生成器： 12$ hexo generate // 生成静态文件$ hexo generate -w // 监视文件变动并立即重新生成静态文件 既然hexo s和hexo g的编译结果不一样，而hexo g -w和hexo s同样是动态编译，是不是就可以生成想要的结果呢？ Did it! 写在最后Hello World，大概是每人程序员写的第一个程序了。记得去年阿里18周年年会时，黄龙外就挂着“Hello World”的巨幅喷绘。 我在想，你善待世界，大概世界也会善待你吧！ 这应该算是我第一篇严格意义上的博客了，写博客是进入一个新世界，每一天、每一段旅程都是进入一个新世界。 我常常会跟女朋友讲我在学的、在做的东西，我总试着用最通俗的语言让她也能明白。前段时间，看了一位网友写自己理解闭包的博客，里面有句话让我印象深刻：“如果一个概念你不能用一两句话说明白，那你就是没有真正地懂。” 真是精辟！于是，我计划着写算是一个系列吧，用最通俗、精练的话去总结一些前端的基础问题。一来总结的过程是对自己的提高，为今年的校招做准备，二来要是能对谁有一点帮助那就意外的收获了。 这个系列或许可以叫“前端那些事儿”之类的吧，哈哈！当年明月通俗幽默讲明史，我为何不可通俗幽默说前端呢？ “开机，启动，接入！” 既然选择了远方，便只顾风雨兼程——汪国真]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初次见面，请多指教]]></title>
    <url>%2F2018%2F01%2F18%2Fnice-to-meet-you%2F</url>
    <content type="text"><![CDATA[大家好，你们可以叫我萧文，也可以叫我Albert。 萧文，这个名字和我颇有渊源，小时候就差点叫了这个名字。我在想，以后要是进了哪个厂，我的花名就叫萧文了。 关于我的英文名有个小故事：高中时，英语老师以抽签的方式给每人都取了个英文名，还告诉我Albert有“聪明、高贵、人类的守护者”的意思，我也就阴差阳错地承担起了守护人类、拯救地球的责任。哈哈！ 高考填志愿时，凭着自己多年来练就的“3秒修好掉链条的单车”的天赋，我报了机械专业，自此离拯救地球的道路远走远远。还好，当时学了个C语言程序设计。 本科毕业后，来杭州读了个小硕。没错，还是机械╯▂╰。可是我读的专业是机械和计算机的结合呀，哈哈哈！ 众多CS方向中，我选择了前端。为啥？喜欢呗！我发现这是一个可以将我所有的兴趣都结合起来的。。。 什么呢？ 嗯，事业！！！ 前端太好玩了！什么设计、图形、webGL、动画、游戏、业务、数据可视化、算法，各种新工具、新技术，应有尽有。 有句话叫做：“有人的地方就有江湖。”我想说：“未来的时代，有人的地方就有前端。” 扯了这么多，该滚去学习了。 还有很多知识要学，还有好多代码要写，长路漫漫，任重道远。。。]]></content>
      <categories>
        <category>随想</category>
      </categories>
  </entry>
</search>
