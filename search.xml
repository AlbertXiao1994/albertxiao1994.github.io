<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[排序算法——春招读书笔记（八）]]></title>
    <url>%2F2018%2F03%2F27%2Fsort%2F</url>
    <content type="text"><![CDATA[数据结构和算法，是每个程序员的基本素养，前端工程师也不例外。之前也定下了重学数据结构与算法的计划，用大概两个月的时间把《剑指offer》过一遍。今天，先整理整理排序算法。 通用函数开始整理前，我们先定义一个通用函数： 12345function swap(arr, i, j) &#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125; 它的功能就是互换数组中位置i、j处的值。 冒泡排序基本思想：两层循环，每一轮循环从头开始两两比较，更大的往后冒泡；当一轮结束时，当前轮最大的数冒泡到数组最后。 复杂度：O(n²) 12345678910111213function bubbleSort(arr) &#123; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; for (var j = 0; j &lt; len -i -1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; swap(arr, j, j + 1); &#125; &#125; &#125; return arr;&#125;var arr = [3, 2, 10, 5, 1, 8, 4, 6, 7, 9];bubbleSort(arr); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 每一轮都有一个数排好序，所以j的上界为len-i-1,减少不必要的比较。 选择排序基本思想：两层循环，每轮将头部元素作为最小值参照，遍历数组替换头部最小值。 复杂度：O(n²) 12345678910111213function selectSort(arr) &#123; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[i]) &#123; swap(arr, i, j); &#125; &#125; &#125; return arr;&#125;var arr = [3, 2, 10, 5, 1, 8, 4, 6, 7, 9];selectSort(arr); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 插入排序基本思想：它就像打扑克时配牌一样，即将未排序的元素依次往已排序的数组里插空。 复杂度：O(n²)。 在小型数组情况下，插入排序比前两种要好。 12345678910111213function insertSort(arr) &#123; for (var i = 1, len = arr.length; i &lt; len; i++) &#123; for (var j = i - 1; j &gt;= 0; j--) &#123; if (arr[j] &gt; arr[j + 1]) &#123; swap(arr, j, j + 1) &#125; &#125; &#125; return arr;&#125;var arr = [3, 2, 10, 5, 1, 8, 4, 6, 7, 9];insertSort(arr); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 希尔排序基本思想：按一定间隔将数组分组，每组内进行插入排序；减小间隔，重复以上过程，直至间隔为1。 复杂度：O(nlogn) 12345678910111213141516function shellSort(arr) &#123; var len = arr.length; for (var gap = Math.floor(len / 2); gap &gt;= 1; gap = Math.floor(gap / 2)) &#123; for (var i = gap; i &lt; len; i++) &#123; for (var j = i - gap; j &gt;= 0; j = j -gap) &#123; if (arr[j] &gt; arr[j + gap]) &#123; swap(arr, j, j + gap); &#125; &#125; &#125; &#125; return arr;&#125;var arr = [3, 2, 10, 5, 1, 8, 4, 6, 7, 9];shellSort(arr); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 归并排序基本思想：采用分治和递归的思想，将数组分成两部分，每部分递归排序;从已排好序的两部分数组中，按大小依次取出元素放入新数组。 复杂度：O(nlogn) 123456789101112131415161718192021222324252627282930313233343536function mergeSort(arr) &#123; var len = arr.length; // 仅有一个元素 if (len &lt; 2) &#123; return arr; &#125; var middle = Math.floor(len / 2); var left = arr.slice(0, middle); var right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));&#125;function merge(left, right) &#123; var result = []; while (left.length &gt; 0 &amp;&amp; right.length &gt; 0) &#123; if (left[0] &lt; right[0]) &#123; result.push(left.shift()) &#125; else &#123; result.push(right.shift()) &#125; &#125; while(left.length) &#123; result.push(left.shift()) &#125; while(right.length) &#123; result.push(right.shift()) &#125; return result;&#125; 快速排序这是一道送分题。快排，是面试时被问到最多的。一般，前端的面试算法部分问到快排就差不多到头了。 基本思想：也是分治思想，将数组分为左右两部分，每部分以头部元素作为参考，比它小的放左边，比它大的放右边，接着递归，直到子数组长度为1。 复杂度：O(nlogn)。 它最坏的情况是对顺序数组排序，为O(n²)；平均时间是O(nlogn)，比其他的O(nlogn)的算法好。 1234567891011121314151617181920212223242526272829303132333435function quickSort(arr, left, right) &#123; // 左界限 var left = typeof left === "number" ? left : 0; // 右界限 var right = typeof right === "number" ? right : arr.length - 1; // 递归终止条件 if (left &lt; right) &#123; // 中间元素的位置 var centerIndex = getCenterIndex(arr, left, right); quickSort(arr, left, centerIndex - 1); quickSort(arr, centerIndex + 1, right); &#125; return arr;&#125;function getCenterIndex(arr, left, right) &#123; // 游标，标记参考值的位置 var cursor = left + 1; for (var i = left + 1; i &lt;= right; i++) &#123; if (arr[left] &gt; arr[i]) &#123; swap(arr, cursor++, i) &#125; &#125; // 将参考元素换至中间位置 swap(arr, left, cursor -1); return cursor -1;&#125;var arr = [3, 2, 10, 5, 1, 8, 4, 6, 7, 9];quickSort(arr); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 堆排序基本思想：将一个数组堆化，即保证节点处元素大于等于子节点；互换头尾元素，堆长度递减；重复以上过程。 12345678910111213141516171819202122232425262728293031323334353637383940function heapSort(arr) &#123; var heapSize = arr.length; buildHeap(arr); while (heapSize &gt; 1) &#123; heapSize--; swap(arr, 0, heapSize); heapify(arr, heapSize, 0); &#125;&#125;function buildHeap(arr) &#123; var heapSize = arr.length; for (var i = Math.floor(heapSize / 2); i &gt;= 0; i--) &#123; heapify(arr, heapSize, i); &#125;&#125;function heapify(arr, heapSize, i) &#123; var left = i * 2 + 1; var right = i * 2 + 2; var largest = i; if (left &lt; heapSize &amp;&amp; arr[left] &gt; arr[largest]) &#123; largest = left; &#125; if (right &lt; heapSize &amp;&amp; arr[right] &gt; arr[largest]) &#123; largest = right; &#125; if (largest !== i) &#123; swap(arr, largest, i); heapify(arr, heapSize, largest) &#125;&#125;var arr = [3, 2, 10, 5, 1, 8, 4, 6, 7, 9];heapSort(arr); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>时间复杂度</tag>
        <tag>空间复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[setState后发生了什么——春招读书笔记（七）]]></title>
    <url>%2F2018%2F03%2F26%2Flearning-notes-seven%2F</url>
    <content type="text"><![CDATA[关于setState的批处理，有个经典的问题： 123456789101112131415161718192021222324252627282930class Example extends React.Component &#123; constructor() &#123; super(); this.state = &#123; val: 0 &#125;; &#125; componentDidMount() &#123; this.setState(&#123;val: this.state.val + 1&#125;); console.log(this.state.val); // 第 1 次 log this.setState(&#123;val: this.state.val + 1&#125;); console.log(this.state.val); // 第 2 次 log setTimeout(() =&gt; &#123; this.setState(&#123;val: this.state.val + 1&#125;); console.log(this.state.val); // 第 3 次 log this.setState(&#123;val: this.state.val + 1&#125;); console.log(this.state.val); // 第 4 次 log &#125;, 0); &#125; render() &#123; return null; &#125;&#125;;// 输出0,0,2,3 在网上看了很多博客，但没有一个完全讲清楚的。 下面说说我的理解。 1、this.setstate我们调用setstate，实际上干了这么一件事： 1234567ReactComponent.prototype.setState = function(partialState, callback) &#123; ... this.updater.enqueueSetState(this, partialState); if (callback) &#123; this.updater.enqueueCallback(this, callback, 'setState'); &#125;&#125;; 里面的updater是一个ReactUpdateQueue对象，它在组件初始化时被注入。 2、 enqueueSetState它将新的局部state放入当前组件实例的_pendingStateQueue，之后调用enqueueUpdate： 12345678910111213141516171819enqueueSetState: function(publicInstance, partialState) &#123; ... var internalInstance = getInternalInstanceReadyForUpdate( publicInstance, 'setState' ); if (!internalInstance) &#123; return; &#125; var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []); queue.push(partialState); enqueueUpdate(internalInstance);&#125; 那enqueueUpdate函数起什么作用呢？ 3、enqueueUpdate123456789101112131415function enqueueUpdate(component) &#123; ensureInjected(); ... if (!batchingStrategy.isBatchingUpdates) &#123; batchingStrategy.batchedUpdates(enqueueUpdate, component); return; &#125; dirtyComponents.push(component); if (component._updateBatchNumber == null) &#123; component._updateBatchNumber = updateBatchNumber + 1; &#125;&#125; 它的核心功能是：判断当前是否是批处理状态，如果不是，则将enqueueUpdate作为事务的回调执行，并将当前组件加入dirtyComponents数组。 你可能会好奇事务是什么？ 事务的功能就是提供一个wrapper包装一个函数，使得能在函数执行前后通过initial、close方法执行一些逻辑。 一个事务的执行流程：initial–&gt;callback–&gt;close。 enqueueUpdate注入了两个依赖，其中一个很重要的就是下面的batchingStrategy。 4、batchedUpdates可以看到，它有一个isBatchingUpdates，标志当前是否处于批量更新阶段。 12345678910111213141516var ReactDefaultBatchingStrategy = &#123; isBatchingUpdates: false, batchedUpdates: function(callback, a, b, c, d, e) &#123; var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates; ReactDefaultBatchingStrategy.isBatchingUpdates = true; // The code is written this way to avoid extra allocations if (alreadyBatchingUpdates) &#123; return callback(a, b, c, d, e); &#125; else &#123; return transaction.perform(callback, null, a, b, c, d, e); &#125; &#125;,&#125;; batchingStrategy对象里有个事务transaction，它的wrapper长这样： 12345678910111213// 函数执行后重置标志isBatchingUpdatesvar RESET_BATCHED_UPDATES = &#123; initialize: emptyFunction, close: function() &#123; ReactDefaultBatchingStrategy.isBatchingUpdates = false; &#125;,&#125;;// 函数执行后执行批量更新var FLUSH_BATCHED_UPDATES = &#123; initialize: emptyFunction, close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates),&#125;; 可见，一个事务可以有多个wrapper，依次执行。 123456789101112131415161718var flushBatchedUpdates = function() &#123; while (dirtyComponents.length || asapEnqueued) &#123; if (dirtyComponents.length) &#123; var transaction = ReactUpdatesFlushTransaction.getPooled(); // 关键 transaction.perform(runBatchedUpdates, null, transaction); ReactUpdatesFlushTransaction.release(transaction); &#125; if (asapEnqueued) &#123; asapEnqueued = false; var queue = asapCallbackQueue; asapCallbackQueue = CallbackQueue.getPooled(); queue.notifyAll(); CallbackQueue.release(queue); &#125; &#125;&#125;; 这个方法当dirtyComponents长度大于0时，执行“刷新事务”，调用runBatchedUpdates方法。 6、runBatchedUpdates12345678910111213function runBatchedUpdates(transaction) &#123; // ... for (var i = 0; i &lt; len; i++) &#123; var component = dirtyComponents[i]; // ... ReactReconciler.performUpdateIfNecessary( component, transaction.reconcileTransaction, updateBatchNumber, ); // ... &#125;&#125; 它的核心功能是依次对“脏组件”执行performUpdateIfNecessary。 7、performUpdateIfNecessary123456789performUpdateIfNecessary: function( internalInstance, transaction, updateBatchNumber ) &#123; ... internalInstance.performUpdateIfNecessary(transaction); ... &#125; 而它其实调用实例本身的performUpdateIfNecessary方法。 8、updateComponent1234567891011121314151617181920performUpdateIfNecessary: function(transaction) &#123; if (this._pendingElement != null) &#123; ReactReconciler.receiveComponent( this, this._pendingElement, transaction, this._context ); &#125; else if (this._pendingStateQueue !== null || this._pendingForceUpdate) &#123; this.updateComponent( transaction, this._currentElement, this._currentElement, this._context, this._context ); &#125; else &#123; this._updateBatchNumber = null; &#125; &#125; 它核心的是updateComponent方法。 9、updateComponent1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071updateComponent: function( transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext ) &#123; var inst = this._instance; ... var willReceive = false; var nextContext; var nextProps; // Determine if the context has changed or not if (this._context === nextUnmaskedContext) &#123; nextContext = inst.context; &#125; else &#123; nextContext = this._processContext(nextUnmaskedContext); willReceive = true; &#125; nextProps = nextParentElement.props; // Not a simple state update but a props update if (prevParentElement !== nextParentElement) &#123; willReceive = true; &#125; // An update here will schedule an update but immediately set // _pendingStateQueue which will ensure that any state updates gets // immediately reconciled instead of waiting for the next batch. if (willReceive &amp;&amp; inst.componentWillReceiveProps) &#123; ... inst.componentWillReceiveProps(nextProps, nextContext); ... &#125; var nextState = this._processPendingState(nextProps, nextContext); var shouldUpdate = true; if (!this._pendingForceUpdate &amp;&amp; inst.shouldComponentUpdate) &#123; ... shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext); ... &#125; ... this._updateBatchNumber = null; if (shouldUpdate) &#123; this._pendingForceUpdate = false; // Will set `this.props`, `this.state` and `this.context`. this._performComponentUpdate( nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext ); &#125; else &#123; // If it's determined that a component should not update, we still want // to set props and state but we shortcut the rest of the update. this._currentElement = nextParentElement; this._context = nextUnmaskedContext; inst.props = nextProps; inst.state = nextState; inst.context = nextContext; &#125; &#125; 这个方法有三个功能： 判断context是否改变，改变则传入nextContext 比较父元素，判断props是否改变，改变则触发componentWillReceiveProps 通过_processPendingState更新state，根据shouldComponentUpdate的值决定是否调用_pendingForceUpdate更新组件。 10、_processPendingState它是批量更新的关键： 12345678910111213141516171819202122232425262728_processPendingState: function(props, context) &#123; var inst = this._instance; var queue = this._pendingStateQueue; var replace = this._pendingReplaceState; this._pendingReplaceState = false; this._pendingStateQueue = null; if (!queue) &#123; return inst.state; &#125; if (replace &amp;&amp; queue.length === 1) &#123; return queue[0]; &#125; var nextState = assign(&#123;&#125;, replace ? queue[0] : inst.state); for (var i = replace ? 1 : 0; i &lt; queue.length; i++) &#123; var partial = queue[i]; assign( nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial ); &#125; return nextState; &#125; 我们可以看到，它是通过Object.assign来更新state的。这样做有两点效果： 批量更新state 相同的partialState，只会作用一次 批量更新的核心实现上面说了这么多，看得人头昏眼花，但都不足以实现批量更新。那批量更新的核心是什么呢？ 由React触发的事件都会被包装成“批量更新事务” 123456789101112131415161718// ReactEventListener.jsdispatchEvent: function(topLevelType, nativeEvent) &#123; if (!ReactEventListener._enabled) &#123; return; &#125; var bookKeeping = TopLevelCallbackBookKeeping.getPooled( topLevelType, nativeEvent, ); try &#123; // Event queue being processed in the same cycle allows // `preventDefault`. ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping); &#125; finally &#123; TopLevelCallbackBookKeeping.release(bookKeeping); &#125;&#125; 我们可以看到，React派发事件时，会调用batchedUpdates。 总结说到这我们可以来理一理了： 初始时，isBatchingUpdates为false。 我们通过React调用一个函数，如componentDidMount，它将被作为事务回调。 执行batchedUpdates，isBatchingUpdates置为true，执行函数的内部逻辑。 函数内部的若干个this.setstate依次，这时由于isBatchingUpdates置为true,相关组件被标记为“脏组件”。 当函数执行完毕时，isBatchingUpdates置为false，执行flushBatchedUpdates批量更新state，组件更新。 当函数被的异步操作完成后，调用的this.setstate，此时isBatchingUpdates为false，enqueueUpdate作为事务回调。 isBatchingUpdates置为false，enqueueUpdate再次执行，当前组件被标记为“脏组件”，回调执行完毕，调用close，执行flushBatchedUpdates直接更新state` 至此，就完整解释了this.setstate的原理。 参考资料 React 源码剖析系列 － 解密 setState Batch Update 浅析 React setState 解读 拆解setState[一][一源看世界][之React] 拆解setState[二][一源看世界][之React] 拆解setState[三][一源看世界][之React] React源码]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>setState</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Interview Review]]></title>
    <url>%2F2018%2F03%2F22%2Finterview-review%2F</url>
    <content type="text"><![CDATA[昨天面了一个下午，强度可真大，车轮战，4轮，3个半小时。暴露了一些问题，在此自我复查下。 你真的懂递归？我遇到这样一题： 不使用for和while，实现一个函数prefill(n, v)：返回一个数组a = [v, v, …, v]，其中含有n个v。 当时想到了用递归实现，但卡在了递归调用上。 先上递归的经典例子： 1234567// 求阶乘function factorial(n) &#123; if (n === 1) &#123; return n; &#125; return n*factorial(n-1)&#125; 递归，其实都有一样的套路。先是终止条件，然后递归调用：123456789101112131415161718function prefill(n, v) &#123; var arr = []; function recurse(k) &#123; if (k === 0) &#123; return arr; &#125; arr[arr.length] = v return recurse(k-1); &#125; // 递归调用 recurse(n) return arr;&#125;prefill(5, 1) // [1, 1, 1, 1, 1] 3月23日更新 上面的解法还有些不够简洁，程序员就是要有Geek的精神： 12345678910111213function prefill(n, v) &#123; var arr = arguments[2] || []; if (n === 0) &#123; return arr; &#125; arr.push(v); return prefill(n-1, v, arr);&#125;prefill(5, 1) // [1, 1, 1, 1, 1] 上面把函数嵌套给干掉了，代码优雅了些。 但其实，还有更优雅的方法： 123456789101112function prefill(n, v) &#123; if (n === 0) &#123; return []; &#125; var arr = prefill(n-1, v); arr.push(v); return arr;&#125;prefill(5, 1) // [1, 1, 1, 1, 1] 递归还有一个尾递归优化，像上面的求阶乘的函数： 12345678function factorial(n, total) &#123; if (n === 1) &#123; return total; &#125; return factorial(n-1, n*total)&#125;factorial(5, 1) // 120 将一个递归函数改成尾递归，仅需将原来使用到的局部变量变成函数参数。这样系统仅需保存一个调用记录，而不用维护一个庞大的调用栈，防止了内存溢出。 CSS优先级1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /*.text &#123; color: red; &#125;*/ #parent .em &#123; color: green; &#125; .child .em &#123; color: black; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="parent" id="parent"&gt; &lt;div class="child" id="child"&gt; &lt;div class="em"&gt; &lt;p class="text"&gt;Hello World&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;// 为红色 针对上面的例子，可以总结出几点规则： 1. 指定样式优先于继承样式就像上面这样。 2. 离得近的继承样式优先级高加入内部样式像这样： 123456789&lt;style&gt; .parent &#123; color: green; &#125; .child &#123; color: black; &#125;&lt;.style&gt;// 黑色 3. 权重大的选择器优先级高有这么一个规则： 继承&lt;通用选择器&lt;元素选择器&lt;类选择器=属性选择器=伪类&lt;ID选择器&lt;内联样式 1234567891011121314151617&lt;style&gt; #child &#123; color: green; &#125; .child &#123; color: black; &#125;&lt;.style&gt;// ...&lt;div class="child" id="child"&gt; &lt;div class="em" id="em"&gt; &lt;p class="text"&gt;Hello World&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;// 绿色 属性选择器=类选择器=伪类：123456789101112131415&lt;style&gt; .text &#123; color: green; &#125; [class="text"] &#123; color: red; &#125; .text:hover &#123; color: black;&lt;/style&gt;// ...&lt;p class="text"&gt;Hello World&lt;/p&gt;// 起初：红色；悬停：黑色 4. 隔代距离不影响优先级12345678910111213141516171819&lt;style&gt; .parent .em &#123; color: green; &#125; .child .em &#123; color: black; &#125;&lt;.style&gt;// ...&lt;div class="parent" id="parent"&gt; &lt;div class="child" id="child"&gt; &lt;div class="em" id="em"&gt; &lt;p class="text"&gt;Hello World&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;// 黑色 5. 直接计算优先级以上四点，基本够日常使用。但有时会出现些特殊情况，我们可以通过计算优先级来比较： 权重： 内联样式：1000 ID选择器：100,出现了a次 类选择器=属性选择器=伪类：10,出现了b次 元素选择器：1,出现了c次 通用选择器：0 优先级=100a+10b+c 你猜下面这个是什么结果： 1234567891011121314151617&lt;style&gt; #child .text &#123; color: red; &#125; #em p &#123; color: green; &#125;&lt;/style&gt;// ...&lt;div class="child" id="child"&gt; &lt;div class="em" id="em"&gt; &lt;p class="text"&gt;Hello World&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;// 红色 第一组选择器的优先级=100+10=110 第二组选择器的优先级=100+1=101 有了上面5条大法，基本够用了。妈妈再也不用担心我的样式覆盖错乱了。 声明提升123456F = 0;function F() &#123;&#125;var F = 11;console.log(typeof F) // 'number'console.log(F) // 11 变量、函数声明都会提升到当前作用域的顶部。所以，上面这个例子相当于： 1234567function F() &#123;&#125;var F;F = 0;F = 11;console.log(typeof F) // 'number'console.log(F) // 11 再谈异步编程有了ES6的迭代器，我们有两种方法实现多步继发的异步编程。 Thunk函数实现JS中的Thunk函数，我的理解就是一个柯里化： 123456789// 正常情况下读取文件fs.readFile(filename, callback);// Thunk版本var thunk = function (filename) &#123; return function (callback) &#123; fs.readFile(filename, callback); &#125;;&#125; 上面将多参数变成单参数，先传入文件名，最后传入回调函数。 下面是一个通用的Thunk函数，可以将任意异步函数包装成Thunk函数： 12345678910111213141516171819202122// ES5写法var thunk = function (fn) &#123; // 传入异步API return function () &#123; // 传入参数 var args = [].slice.call(arguments); return function (callback) &#123; // 传入回调函数 fn.call(this, args, callback) &#125; &#125;&#125;// ES6写法const thunk = function (fn) &#123; // 传入异步API return function (...args) &#123; // 传入参数 return function (callback) &#123; // 传入回调函数 fn.call(this, ...args, callback) &#125; &#125;&#125;// 使用var readFileThunk = thunk(fs.readFile);readFileThunk(filename)(callback); 有了Thunk版本的读取文件模块，我们可以实现继发： 1234567891011121314151617181920212223242526272829// 定义一个生成器函数function* gen () &#123; var r1 = yield readFileThunk('1.txt') console.log(r1.toString()) var r2 = yield readFileThunk('2.txt') console.log(r2.toString())&#125;// 自动继发执行function run(fn) &#123; var g = fn(); // 调用生成器函数，获得一个迭代器，当前指针指向函数头部 // 作为异步API的回调函数 function next(err, data) &#123; // 先执行一步，指针指向下一个yield // 返回一个对象&#123;value: thunk, done: false/true&#125; // 传入data，作为上一个yield表达式的返回值 var res = g.next(data); if (res.done) &#123; // 判断指针是否到底部 return; &#125; res.value(next); //传入回调函数 &#125; next();&#125;run(gen); 上面的run函数将next作为异步操作的回调传入，保证了多个异步的自动执行，并且保证了继发。 Promise实现Promise实现的思路跟Thunk类似，不同的是yield返回的是一个Promise对象： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 用Promise封装异步操作const readFilePromise = function (filename) &#123; return new Promise(function(resolve, reject) &#123; fs.readFile(filename, function(err, data) &#123; if (err) &#123; reject(err); &#125; resolve(data); &#125;) &#125;);&#125;// 定义一个生成器函数function* gen () &#123; var r1 = yield readFileThunk('1.txt') console.log(r1.toString()) var r2 = yield readFileThunk('2.txt') console.log(r2.toString())&#125;// 自动继发执行function run(fn) &#123; var g = fn(); // 调用生成器函数，获得一个迭代器，当前指针指向函数头部 // 作为异步API的回调函数 function next(err, data) &#123; // 先执行一步，指针指向下一个yield // 返回一个对象&#123;value: Promise, done: false/true&#125; // 传入data，作为上一个yield表达式的返回值 var res = g.next(data); if (res.done) &#123; // 判断指针是否到底部 return res.value; &#125; //传入回调函数 res.value.then(function(data) &#123; next(data); &#125;; &#125; next();&#125;run(gen); 3月23日更新 对于继发的异步操作，链式调用也是一个思路。（这是我从面试官那学到的） 1234567891011// p1、p2是两个Promise实例p1.then((res) =&gt; &#123; // p1完成 doSth(res1); // 关键，返回一个promise，以供链式调用 return p2;&#125;).then((res2) =&gt; &#123; // p2完成 doOtherSth(res2);&#125;)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[未来半年学习计划]]></title>
    <url>%2F2018%2F03%2F19%2Flearn-plan-in-the-future%2F</url>
    <content type="text"><![CDATA[过去一周，面了几轮，自我感觉还好。当我回想过去的努力时，暂时可以感到欣慰了。结果嘛，不知道，应该不会太坏。现在要做的就是不断努力、继续学习，毕竟不会的永远比会的多。就先从半年的规划做起吧！这样具体点。 React和Rax时间：3月19日-3月28日 资料：官方文档 发现阿里内部还是用React居多，哪怕Weex一开始是为Vue定制的。React还得继续学下去。 首先，我要继续研读React文档，当初采用“走着瞧”的战略，提高了框架入门的效率，但是还有不少章节知之甚少。现在差不多对React有了一定的了解，也做了一个完整的项目，是时候仔细全面的再学习一遍了。 其次，Immutable.js在Redux的应用、动画切换等方面，我都需要再研究下。 接着，就是团队技术栈相关——Rax。Rax阿里内部很多部门在用，我打算用一周左右的时间去学习一遍。学习方法呢，这次就不做一个完整的项目了，而是使用官方提供的Playgound。 Node实践时间：3月29日——4月15日 资料：《了不起的Node.js》、官方文档 之前，已经看过一本郭家宝的《Node.js开发指南》，但当时并没有动手实践。下阶段，Node实践必须提上日程。落脚点呢，就是一直想给我妈做的订单系统。 技术选型打算是Node+mpVue+微信小程序+MongoDB。一来，一个全栈项目是对自己很大的锻炼；二来，实践Node；三来，完成一个很久以来的心愿。 设计模式时间：3月19日——3月30日 资料：《Javascript设计模式与开发实践》 曾探的那本设计模式，已经看了有一段时间了。这期间，由于准备面试导致进度缓慢。我给自己定个目标吧，每天看一章。 数据结构与算法时间：3月31日——4月30日 资料：《学习Javascrpit数据结构与算法》、《剑指Offer》 数据结构在16年时就啃过一段时间，后来又搁置了。这是少不了的。我打算再学一遍。 书买来一直没看，虽然自己在网上看了并整理了一些基础的数据结构JS的实现，但总觉得不算系统。该看了！ 我打算这期间呢，结合牛客网《剑指Offer》的33道题来学习。不用带着功利心来刷题，这样感觉不错。 有些东西看不到，但却无时不在。 React、Vue源码研读（3月23日新增）时间：4月1日——7月30日 资料：React、Vue的核心库、路由、状态管理官方文档，网友源码解读博客 前两天面试，有一个师兄给了很中肯的建议： 一个程序员的职业发展有两种：一是往深度发展，成为该领域的架构师；二是往广度发展，成为团队leader或者小公司的CTO，前端、后端，JS、Java、C++等等都懂，能够对项目有个总体的把握，能够快速排查问题所在。 我的想法是，深度、广度需要兼备，但我以深度为主。而深度要想加强，我所用到的技术栈的源码基本需要通读、精通。那个师兄，他就把JDK的源码都看了一遍。 JS进阶（3月23日新增）时间：4月1日——7月30日 资料：《你不知道的的JS》 怎么把这个给忘了！一本犀牛书、一本红皮书是不够的，学习JS永远在路上。 浏览器原理、W3C（3月23日新增）时间：5月1日——6月1日 资料：W3C、博客 Node深入时间：5月1日——6月1日 资料：《深入浅出Node.js》 PWA时间：6月1日——6月30日 前几天面试，问到了PWA相关的问题。我仅对它有个宏观的认识。听TL说未来打算尝试PWA。可以，很酷，学起。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>Rax</tag>
        <tag>数据结构</tag>
        <tag>设计模式</tag>
        <tag>PWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue和Weex——春招读书笔记（六）]]></title>
    <url>%2F2018%2F03%2F12%2Fvue-and-weex%2F</url>
    <content type="text"><![CDATA[Vue数据绑定实现原理 一句话概括：利用Object.defineProperty重写数据的setter、getter，结合发布-订阅模式，当数据变化时，发布消息，调用回调函数更新视图。 它有三个核心模块： Observer：观测数据，发布消息。 Compile：编译模板，添加订阅者，绑定更新函数。 Watcher：产生订阅者实例，执行绑定的回调函数更新视图。 Observer它通过defineReactive()函数递归给data的属性、子属性设置setter、getter。在setter、getter里通过一个Dep对象实现发布-订阅功能。Dep对象实例有一个订阅者集合数组，以及一个notify方法。 每个订阅者是一个订阅者，都是一个Watcher对象实例，对应Vue里定义的一条数据。 当设置新值时将会调用notify方法，它会依次触发订阅者的update函数。 那我们来看看Watcher实例又是如何关联节点的呢？奥秘在Compile里。 Compile它干三件事：  将挂载节点下的所有子节点加入documentFragment。 编译模板，给每条数据新建一个Watcher实例，绑定更新回调函数。 将批处理后的documentFragment一次性插入挂载的根节点。 重点讲讲它是如何编译模板的。 它遍历每一子节点，依次取出它的所有属性attribution。如果是指令，通过substring(2)取出指令类型，通过正则表达式取出指令内容。对于事件指令，则注册给该节点注册事件；如果是其他类型的，则生成一个Watcher实例，传入Vue实例，数据，回调。 Watcher实例化时，会调用自身的get方法，它通过将Dep.target属性临时赋值为当前Watcher实例。这样就建立起了订阅者与节点的关系。 Watcher每个Watcher都有一个update方法，前面已经说过了，它在数据更新时将会调用，而它将会执行更新视图的回调函数，实现视图响应数据变化。 Weex区别：浏览器，HTML，客户端，JS Bundle，还需适配和页面生命周期相关的行为，如创建、刷新、销毁。 解决平台接口差异：提供Weex DOM API适配不同前端框架，针对Weex和浏览器也调用不同的接口实现跨平台渲染。根据VDOM构建渲染指令树，它是遵照W3C标准对DOM的精简。它可以序列化为JSON格式以渲染指令的形式发送给原生渲染引擎。 不同的 Weex 页面对应到浏览器上就相当于不同的“标签页”， 在 JS Framework 中实现了JS Service的功能，主要就是用来解决跨页面复用和状态共享的问题的。 事件传递： Vue调用JS Framework提供的addEvent将事件类型、回调函数传递给JS Framework。JS Framework在构建渲染树是，将事件类型添加至节点中。将在原生组件上将监听这一事件。事件触发时通过fireElemt节点信息回传给JS Framework，在JS Framework里执行。 这种方式效率很低，可能一次触发多次执行回调。可以表达式绑定将回调以字符串的形式直接传给客户端。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>观察者模式</tag>
        <tag>Weex</tag>
        <tag>Object.defineProperty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步编程——春招读书笔记（五）]]></title>
    <url>%2F2018%2F03%2F11%2Fasync-programming%2F</url>
    <content type="text"><![CDATA[ES5异步编程 回调函数 注册事件 发布-订阅模式 Promise（我并没有在ES5接触过） ES6异步编程Promise它有三种状态：pending、fullfilled、reject。 用法： 12345678let promise = new Promise(function() &#123; $.getJSON('url', function(data) resolve(data)) &#125;)promise.then((res) =&gt; &#123; console.log(res.data) &#125;) 有一点需要注意： 1234567891011121314151617setTimeout(function () &#123; console.log(3);&#125;, 0);new Promise((resolve, reject) =&gt; &#123; resolve(4); console.log(2);&#125;).then(r =&gt; &#123; console.log(r);&#125;);console.log(1);// 2// 1// 4// 3 它的参数函数是同步执行的，所以最早打印4，接着是同步打印1。 这个Promise是直接resolve的，它将在本轮事件循环的结束时执行，而setTimeout将在下一轮事件循环的开始时执行。 generator函数1234567891011function * gen() &#123; yield '1' yield '2' return '3'&#125;var g = gen()g.next() // &#123;value: '1', done: false&#125;g.next() // &#123;value: '2', done: false&#125;g.next() // &#123;value: '3', done: true&#125; 执行generator函数返回Iterator对象。调用next方法控制它的进行。 再上自动执行器，它就可以完成自动完成异步操作。 有两种方法： Thunk函数 Co模块 Thunk函数把多参数函数变成单参数函数，而这个参数就是异步回调。如下面定义一个用于异步读取文件的Thunk函数： 123456789101112const Thunk = function (fn) &#123; return function(...args) &#123; return function(callback) &#123; return fn.call(this, ...args, callback) &#125; &#125;&#125;var readFileThunk = Thunk(fs.readFile)// 调用readFileThunk('./1.png')(callback) 定义我们需要的生成器函数： 123456var gen = function* ()&#123; var r1 = yield readFileThunk('/etc/fstab'); console.log(r1.toString()); var r2 = yield readFileThunk('/etc/shells'); console.log(r2.toString());&#125;; 那怎么让它自动执行呢？ 12345678910111213141516function run (fn) &#123; // 返回迭代器对象，指针在生成器函数头部 var gen = fn() // next为异步操作的回调函数 function next(err, data) &#123; var result = gen.next(data); if (result.done) return; // 传入回调函数，执行 result.value(next); &#125; next();&#125;run (gen) 还可以通过Co模块实现自动化。 它有两种方法：一是通过Promise，而是通过Thunk。 讲讲Promise怎么实现。关键点两个：一是yield返回Promise；二是next函数里通过then继续进行。 1234567891011121314151617var fs = require('fs');var readFile = function (fileName)&#123; return new Promise(function (resolve, reject)&#123; fs.readFile(fileName, function(error, data)&#123; if (error) return reject(error); resolve(data); &#125;); &#125;);&#125;;var gen = function* ()&#123; var f1 = yield readFile('/etc/fstab'); var f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; 上面是第一个关键点。 1234567891011121314151617function run(gen)&#123; // 返回迭代器对象，指针在生成器函数头部 var g = gen(); function next(data)&#123; var result = g.next(data); if (result.done) return result.value; // 给它注册then方法，传入next方法，执行promise result.value.then(function(data)&#123; next(data); &#125;); &#125; next();&#125;run(gen); async函数async函数它就是generate函数的语法糖。 1234const asyncReadFile = async function () &#123; const f1 = await fs.readFile('./1.txt') const f2 = await fs.readFile('./2.txt')&#125; 它更加简洁、语义化，自动执行，而且返回Promise对象。 而它的原理，就是Co模块的Promise式嘛 好了，到此你就可以愉快地异步编程了！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Promise</tag>
        <tag>Generator</tag>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂七杂八——春招读书笔记（四）]]></title>
    <url>%2F2018%2F03%2F11%2Ftalk-others%2F</url>
    <content type="text"><![CDATA[data必须是个函数一个常见的问题，就是为什么data必须是个函数。 可是，这个问题并不是一定成立的。它得在组件中才有意义。 官方文档说： 在组件中，多数的组件选项可以传递给Vue构造函数，然后共享于多个组件实例，然而有一个特例：data 必须是一个函数。 这句话有点隐晦，应该data不是定义在构造函数中，而是定义在原型中。 如果像下面这样： 123456Vue.component('my-component', &#123; template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;', data: &#123; message: 'hello' &#125;&#125;) 直接将data定义为一个引用类型的值，那就会出现原型中的经典问题——对该值的操作，为所有实例共享。 因此，Vue有个规避设计。这样写直接报错，告诉你必须是一个函数，无法运行。 但是有种方法可以悄无声息的通过检查，但却导致错误的运行结果： 1234567var data = &#123; counter: 0 &#125;Vue.component('comp', &#123; data: function () &#123; return data &#125;&#125;) 它把data定义为一个函数，但实际运行时却因为返回的是同一个对对象的引用，还是那个问题。 最后，解决方案就是，直接返回一个新对象。 1234567Vue.component('comp', &#123; data: function () &#123; return &#123; counter: 0 &#125; &#125;&#125;) 其实，第二种错误只是文档为了帮助我们理解，实际使用时一般不会这么做。 get和post的区别 1）get主要用于获取数据，post主要用于新增数据 2）get使用cookie或者url传数据，而post使用实体主体。 3）get有长度限制，post则可以很大。 4）get数据外漏，不安全。 5）get具有幂等性，多次请求，同结果。 ES6模块与CommonJS模块有什么区别 1）前者是编译时输出接口，后者是运行时加载。 2）前者是值引用，后者是值复制。 关于第一点，前者是静态解析时得到一个引用，后者是运行时创建一个module.exports对象。 关于第二点，前者是得到一个引用，那模块内部的变化就可得到。因此，在不同地方加载得到的是同一个实例。 而对于CommonJS模块，基本数据类型的值，无法获得实时的值: 1234567891011121314151617// lib.jsvar counter = 3;function incCounter() &#123; counter++;&#125;module.exports = &#123; counter: counter, incCounter: incCounter,&#125;;// main.jsvar mod = require('./lib');console.log(mod.counter); // 3mod.incCounter();console.log(mod.counter); // 3 在main.js中，mod是原模块的一份复制，couter的值得到后就不会变了。 viewport在做移动web时，我们经常使用下面这样的头： 1&lt;meta name="viewport" content="width=device-width;initial-scale=1.0;max-scale=1.0;min-scale=1.0;user-scalable=no"&gt; 下面一一讲讲我的理解： width=device-width：设置的是布局视口的宽度等于设备的dip宽度。这个值在媒体查询时发挥作用。 *-scale=1.0：这个sacle，等于设备的dip与web里的dip的比值。 那dip是什么呢？逻辑像素。CSS的1px就是1个逻辑像素。而它控制设备的几个物理像素，得根据dpr的值来定。而不同设备（PC和移动端）的dip是不一样的，我们通过设置这个scale得到了他们的关系。 CSS草图布局草图布局是首屏优化的一大方法，我们再支付宝、饿了么中可以看到。通过给元素设置:empty伪类样式，即可避免白屏： 123456789101112131415161718192021222324252627282930313233&lt;div class="wrapper"&gt;&lt;/div&gt;wrapper:empty &#123; margin: auto; width: 500px; height: 600px; background-image: radial-gradient( circle 50px at 50px 50px, lightgray 99%, transparent 0), linear-gradient( 100deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.5) 50%, rgba(255, 255, 255, 0) 80% ), linear-gradient( lightgray 20px, transparent 0 ), linear-gradient( lightgray 20px, transparent 0 ), linear-gradient( lightgray 20px, transparent 0 ), linear-gradient( lightgray 20px, transparent 0 ); background-repeat: repeat-y; background-size: 100px 200px, /* circle */ 50px 200px, /* highlight */ 150px 200px, 350px 200px, 300px 200px, 250px 200px; background-position: 0 0, /* circle */ 0 0, /* highlight */ 120px 0, 120px 40px, 120px 80px, 120px 120px;&#125; XSS和CSRFXSS：跨站脚本攻击，就是想办法在你的电脑上执行脚本获取cookie。 防范： 过滤用户输入，过滤掉除了合法值以外的所有。 进行HTML编码。 设置cookie的httpOnly属性。 对url进行编码，过滤。 CSRF：跨站请求伪装，主要就是通过图片src的形式，诱导你的浏览器去加载它，并将cookie上传。 防范： 检查referer。 设置验证码。 将请求方法限制为POST。 设置token。 Event Loop JS引擎通过执行栈去执行同步代码 对同步代码里的异步API，如I/O操作、点击、滚动，只将请求发出，而将它回调函数挂起。 异步任务完成后，以事件的形式加入“任务队列” 执行栈同步代码执行完成后，去遍历执行“任务队列”里事件的回调函数。 这一过程循还往复。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>vue</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scroll组件原理和优化——春招读书笔记（三）]]></title>
    <url>%2F2018%2F03%2F11%2Foptimization%2F</url>
    <content type="text"><![CDATA[我们常常会有加载长列表的需求，而它有两点性能瓶颈： 里面包含大量图片，需要发送大量的HTTP请求和下载 需要暴露列表的实时位置，这就会导致scroll事件的触发频率很高 之前在做Vue的项目时，用过一款挺好用的scroll组件——better-scroll。它在Vue下的性能很好，在不断触发滚动事件暴露当前位置时也能不错的体验。如果配合vue-lazyload还可以实现图片懒加载，提高性能。它本身也有一个scrollEnd事件，注册它可以实现按需加载。 那如何判断滚动底部了呢？ clientHeight：浏览器可视区域高度 scrollTop：Y方向上当前滚动距离 scrollHeight：我的理解就是页面高度。 clientHeight和scrollHeight是不变的。初始时，scrollTop=0；滚动底部时，clientHeight+scrollTop=scrollHeight 有了后面这个条件，就可以判断是否到底部了。一般会预留一些距离，就是快到底部时就加载需要的数据。 那是局部滚动时如何判断到底部呢？ 我的思路是可以尝试下offset-系列的属性。 offsetTop：一般情况为文档坐标下的Y值，但如果祖先元素已定位，为相对祖先元素的Y值。 offsetWidth：元素高度 或许，我们可以先将父元素相对定位，然后比较offsetTop是否等于offsetHeight，这样就可以判断是否到底部了。 Better-Scroll给scroll事件注册一个校验是否到底部的回调函数，当到达底部时，触发默认绑定的自定义事件scrollEnd： 1234567891011121314151617BScroll.prototype._watchPullUp = function () &#123; this.pullupWatching = true const &#123;threshold = 0&#125; = this.options.pullUpLoad this.on('scroll', checkToEnd) function checkToEnd(pos) &#123; if (this.movingDirectionY === DIRECTION_UP &amp;&amp; pos.y &lt;= (this.maxScrollY + threshold)) &#123; // reset pullupWatching status after scroll end. this.once('scrollEnd', () =&gt; &#123; this.pullupWatching = false &#125;) this.trigger('pullingUp') this.off('scroll', checkToEnd) &#125; &#125; &#125; 解决了判断是否到底部，那图片懒加载又是如何实现的呢？ 在JS中，有个代理模式。 123456789101112131415161718192021222324var myImg = (function() &#123; var img = document.creatElemet('img') document.body.appendChild(img) return &#123; setSrc: function(src) &#123; img.src = src &#125; &#125;&#125;)()var proxyImg = (function() &#123; var img = new Image() img.onload = function() &#123; myImg.setSrc = (this.src) &#125; return &#123; setSrc: function(src) &#123; myImg.setSrc('file://loading.png') img.src = src &#125; &#125; &#125;)() 上面这种模式，将图片的DOM相关的操作和懒加载功能分离，遵从了单一职责原则。预先加载本地图片，而本地文件是只需要加载一次的，这样利于了缓存，给用户一个良好的体验。等远程图片下载完成，也就是在代理的img.onload触发时，将原图片的src换成远程图片。 进一步优化，还可以在节点插入上做文章。 也就是将一系列节点统一插入DOM，减小DOM操作： 12345678var fragment = document.createDocumentFragment()for (var i; i &lt; 10; i++) &#123; var img = document.creatElemet('img') fragment.appendChild(img)&#125;document.appendChild(fragment) better-scroll在Vue中有不错的表现，可我在做一个React项目时，却遇到了问题。 我需要暴露出组件的当前位置，以和左侧栏导航栏做一个响应。这个功能在Vue上很流畅，但在React中卡的不行。 我做了两步去优化它： 使用immutable.js优化shouldComponentUpdate； 函数节流 12345678910111213141516171819202122232425262728293031import &#123; is &#125; from 'immutable'class Wrapper extends React.Component &#123; shouldComponentUpdate(nextProps, nextState) &#123; const thisProps = this.props || &#123;&#125;, thisState = this.state || &#123;&#125;; if (Object.keys(thisProps).length !== Object.keys(nextProps).length || Object.keys(thisState).length !== Object.keys(nextState).length) &#123; return true; &#125; for (const key in nextProps) &#123; if (!is(thisProps[key], nextProps[key])) &#123; return true; &#125; &#125; for (const key in nextState) &#123; if (thisState[key] !== nextState[key] || !is(thisState[key],nextState[key])) &#123; return true; &#125; &#125; return false; &#125; // some code render() &#123; return &#123; &lt;Scroll /&gt; &#125; &#125;&#125; 使用后，果然没那么卡了。为什么呢？ 这里就涉及到Vue和React的渲染机制。 Vue是跟踪变化节点的依赖，只更新相关联的那部分，这部分对外是看不到的，开发者不需要关注，也能实现高效重绘。这也是Vue的一个优点。 而React是更新变化节点的所有子节点，这样就带来一些额外的开销。只能通过shouldComponentUpdate来指示是否需要重绘。而判断一个数据是否真的变了，这部分工作就给了immutable.js。 我的代码中，在滚动时state属性变动是这样的： scrollY {Number} - scroll组件实时位置，实时变化 currentIndex {Number} - 根据scrollY条件变化 fixedTitle {String} - 根据currentIndex条件变化 之前，scrollY的更新会调用render()方法，整个子组件都更新了。而在使用了immutable.js后，scroll组件内部并不知道会更新，干掉了一大性能瓶颈。 其实，还可以更进一步，scrollY可以从state里提出，把它定义为组件的属性。为什么呢？ 因为，它并不直接作用于UI，只有在一定条件下它才会间接改变跟UI关联的state属性。 到此为止，scroll组件已经算是比较好用了，但跟不暴露实时位置时的效果还是有明显的差距。 终于到了函数节流了。 像input、resize、scroll这样连续触发的事件，一个常用的优化方法就是函数节流。 我们可以这样定义一个节流函数： 1234567891011121314// util.jsexport function debounce(func, delay) &#123; let timer return function(...args) &#123; if (timer) &#123; return &#125; timer = setTimeout(() =&gt; &#123; func.apply(this, args) clearTimeout(timer) timer = null &#125;, delay) &#125;&#125; 它通过一个闭包，延长了局部变量timer是寿命，还保证在一个延迟时间内只有一次函数调用。 通过它，你就可以避免短时间内大量触发引发大量性能消耗的scroll事件了。 那能不能再进一步呢？ 谷歌浏览器前两年发布了一个新功能：给addEventListener添加{passive:true}选项，将大大提升页面滚动的性能： 12345// 通知浏览器当scroll事件执行时，忽略所有的阻止默认事件语句addEventListener('scroll', &#123;passive:true&#125;)// vue.js中你可以这样写&lt;div v-on:scroll.passive="onScroll"&gt;...&lt;/div&gt; 在React中，我暂时没有找到设置这个属性的方法。 不过，在我看Better-Scroll组件源码时，发现它原生绑定scroll事件时就已经设置了，不过它设置为了false： 123export function addEvent(el, type, fn, capture) &#123; el.addEventListener(type, fn, &#123;passive: false, capture: !!capture&#125;)&#125; 我尝试着修改源码，将它设置为{passive: true}。似乎确实可以感受到滑动的流畅提升。 为了测试兼容性，我决定使用Vue里的做法： 12345678910111213141516var supportsPassive = falsetry &#123; const opts = &#123;&#125; Object.defineProperty(opts, 'passive', (&#123; get () &#123; /* istanbul ignore next */ supportsPassive = true &#125; &#125; : Object)) window.addEventListener('test-passive', null, opts) &#125; catch (e) &#123;&#125;// 注册事件if (type === 'touchstart' || type === 'touchmove' || type === 'touchstart') &#123; el.removeEventListener(type, fn, supportPassive ? &#123; passive:true &#125; : false) &#125; 上面代码，先检测浏览器是否支持Passive Event API。它是通过修改变量supportsPassive的getter取值器函数，当浏览器去调用它时，将会把supportsPassive置为真。注册事件时，就可以通过它来判断是否支持这个API了。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>scroll</tag>
        <tag>懒加载</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈继承——春招读书笔记（二）]]></title>
    <url>%2F2018%2F03%2F10%2Fextend%2F</url>
    <content type="text"><![CDATA[ES5下的继承1、原型链式1234567function superType () &#123;&#125;function subType () &#123;&#125;subType.protoType = new superType() 特点：子类型的原型为超类型的实例。 缺点： 当继承引用类型的值时，那对该引用类型的值的操作，将反映到所有实例上。 不能对超类型的构造函数传值。 重点说下第一点。 一开始，我没有完全懂第一点的含义。 《JS高程》上有个例子： 12345678910111213141516function superType () &#123; this.color=['red', 'blue', 'green']&#125;function subType () &#123;&#125;subType.protoType = new superType()// 子类型实例1var instantce1 = new subType()instantce1.color.push('black')// 子类型实例2var instantce2 = new subType()console.log(instantce2.color) // ['red', 'blue', 'green', 'black'] 子实例2受到了子实例1的影响。原因是color是个引用，定义在原型上，为所有实例共享。 看上去好像是懂了，其实呢？ 不信，问个问题：基本类型的属性也被所有实例共享，那为什么只有引用类型是原型链式的缺点？ 来看看下面这个例子： 1234567891011121314function A () &#123; this.num = 1&#125;function B () &#123;&#125;B.prototype = new A()var b1 = new B()b1.num = 2var b2 = new B()console.log(b2.num) // 1 哎呀，b2.num的值确实没有被影响！ 原因在于，b1.num和b2.num根本不是一个东西。 12b1.num // 新定义在实例b1上，为实例属性b2.num // 从原型那找到的属性 也就是说，对于基本类型的属性，你压根就没有办法改变它的值。其实，对于引用类型的属性，你只是也能通过引用类型自身的方法改变它的值。要是直接赋值的话，一样歇菜。 话说回来，直接赋值那还不如直接定义，没必要继承了。 那有什么办法既继承，又规避上面的缺点呢？借用构造函数。 借用构造函数123456function superType () &#123;&#125;function subType () &#123; superType.call(this)&#125; 直接在子类型中调用超类型的构造函数，那每个子类型实例都拥有它自己的继承而来的属性了。而且，你还可以调用超类型构造函数时给它传值。 问题看似都解决了。可新的问题又来了：超类型的方法无法复用，或者说每次新建实例时都需要新建一次，这会带来额外的开销。 组合式组合式继承结合了前两种的优点，是最常用的方法。 123456789function superType () &#123;&#125;function subType () &#123; superType.call(this)&#125;subType.protoType = new superType()subType.protoType.constructor = superType 这种方法好在哪呢？ 它的目的是：从通过原型链继承方法，通过借用构造函数得到实例自有的继承属性。 它的方法是：先通过原型链继承原型方法和属性,通过借用构造函数覆盖它原型里的属性。 因为实例里就有需要的属性，永远也不会跑去原型那找了。 这种方法也有问题：它调用了两次超类型构造函数，还产生了一些永远也用不上的原型属性。 原型式12345function object (o) &#123; function f () &#123;&#125; f.prototype = o return new f()&#125; 这种方法我觉得并没多特别的。 它的用处就是可以得到有用对象o的一个副本。 你有没有发现它和原型链是很像，连名字都很接近。 当使用原型链法，如果子类型的构造函数是空的时，它们就是一样的。 区别也就出来了：原型式得到一个已有对象的副本，什么共享引用类型、不能传值这些问题它都有；而原型链式，可以在子类型的构造函数里定义一些自有属性方法。 寄生式它和原型式很像，只是多做一点步骤，所谓的增强返回的实例。 12345function createAnother (o) &#123; var clone = object(o) clone.newMethod = function () &#123;&#125; return clone&#125; 寄生组合式还有最后一种，它最强大，集各家所长。 12345678910111213141516function superType () &#123;&#125;superType.someMethod = function () &#123;&#125;function subType () &#123; superType.call(this)&#125;inherit (subType, SurperType)function inherit (subType, superType) &#123; var protytype = object(superType.protytype) subType.protoType = protytype subType.protoType.constructor = superType&#125; 它直接从超类型原型那继承方法，而组合式其实是在原型链上查找方法来继承。 ES5和ES6继承的不同ES6引入了类的概念，但其实它只是ES5的一个语法糖。 1234567891011121314151617181920212223// ES5function A () &#123; this.name = "Albert"&#125;A.protytype.getName = function () &#123; return this.name&#125;// ES6class A &#123; constructor () &#123; thsi.name = "Albert" &#125; getName () &#123; return this.name &#125;&#125;typeof A // 'function'A === A.protytype.constructor // truevar a = new A() 类A是个函数，它指向构造函数。 在ES5中，构造函数负责返回实例。而ES6中，这部分功能由construtor方法完成。 ES6中继承像这样： 123456class Child extends Parent &#123; constructor () &#123; super() this.age = "24" &#125;&#125; super用作函数时，指父类的construtor方法。super用作对象时，在普通函数中指向父类原型；在静态方法中，指向父类。 子类同时具有__proto__和prototype属性。__proto__属性指向父类，prototype属性指向父类原型的实例。 12345678class A &#123;&#125;class B extends A &#123;&#125;B.__proto__ === A // trueB.prototype.__proto__ === A.prototype // true]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>继承</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue router的原理——春招读书笔记（一）]]></title>
    <url>%2F2018%2F03%2F10%2Fread-vue-router-source%2F</url>
    <content type="text"><![CDATA[找工作真是累，现在是感受到了。不但学习强度高，一刻不能懈怠，而且还要承受被面试官面到怀疑人生的境地。过两天就要一面了，在此总结下这段时间基础知识查缺补漏的一些难啃的骨头。但求有一个好人品，到时有一个好结果。 vue router有三种模式：hash、history、abstract。它们在新建Router实例时通过mode选项设置。 this.$router大家都很熟悉，根据我的理解，它其实是一个特殊的history实例。在路由实例初始化时，在构造函数中根据mode和程序运行的环境的支持情况，生成相应的history。如： 12345678910111213141516// 根据mode确定history实际的类并实例化 switch (mode) &#123; case 'history': this.history = new HTML5History(this, options.base) break case 'hash': this.history = new HashHistory(this, options.base, this.fallback) break case 'abstract': this.history = new AbstractHistory(this, options.base) break default: if (process.env.NODE_ENV !== 'production') &#123; assert(false, `invalid mode: $&#123;mode&#125;`) &#125; &#125; 所以，你调用this.$router.push其实是调用这个特殊的history的push方法。那history.push里发生了什么呢？ 所有类型里的history.push大概长这样：1234567891011push (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; const &#123; current: fromRoute &#125; = this this.transitionTo(location, route =&gt; &#123; // HashHistory pushHash(...params) // HTML5History // pushState() // 一些代码 onComplete &amp;&amp; onComplete(route) &#125;, onAbort)&#125; 很明显了，就是通过各自的this.transtionTo方法去往抽象的历史状态队列中添加新状态。 12345678// HashHistoryfunction pushHash (path) &#123; window.location.hash = path&#125;// HTML5HistorypushHash(...params) &#123;windows.history.pushState(stateObject, title, URL) 好了，现在历史状态更新了，那就要更新视图了。 刚才我们只是调用了this.transitionTo()方法，那它执行的结果是啥呢。随我进入实例history的构造函数里，它是一个观察者模式： 123456789101112131415161718transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; const route = this.router.match(location, this.current) this.confirmTransition(route, () =&gt; &#123; this.updateRoute(route) ... &#125;)&#125;updateRoute (route: Route) &#123; // 发布 this.cb &amp;&amp; this.cb(route) &#125;// 订阅listen (cb: Function) &#123; this.cb = cb&#125; 可见，调用它其实是发布了一个route或者说location。那它是在哪里订阅的呢？答：在路由实例初始化时。在VueRouter构造函数里有个init方法： 123456789101112init (app: any /* Vue component instance */) &#123; this.apps.push(app) // 订阅 history.listen(route =&gt; &#123; this.apps.forEach((app) =&gt; &#123; // 给每个组件实例app设置新的_route属性 app._route = route &#125;) &#125;)&#125; 我们都知道，Vue通过Object.defineProperty()重写属性的setter和getter并结合观察者模式实现了数据双向绑定。当数据设置新值时，发布消息，之前注册的事件回调函数里的render()就会把视图更新。 因此，app._route更新时，视图就切走了，好像来到了一个新的页面。 Vue真是把发布订阅模式发挥得淋漓尽致！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue router</tag>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weex! This is for everyone]]></title>
    <url>%2F2018%2F03%2F06%2Fweex-for-everyone%2F</url>
    <content type="text"><![CDATA[Weex，一个让我神往已久的技术。终于到了可以谈一谈的地步。接触weex5天了，坑踩了不少，差不多可以算入门了吧！正式说它之前先谈谈web吧！ 前言web开发技术完全可以说是人类历史上的大量优秀科学家、工程师理论与实践的结果，特别能体现互联网精神：共享、开放。它自诞生之日起，就担负着传播人类文化知识的重任。可以说，web完全不输于人类历史上那些响当当的重要发明，比如：蒸汽机、电灯、智能手机。 如果说，我崇拜谁呢，就蒂姆·伯纳斯·李绝对算一个。当初看央视的纪录片《互联网时代》，一个场面让我叹为观止：蒂姆·伯纳斯·李在2012年当你编写世界上第一个web服务器和客户端的电脑上敲出“This is for everyone”。 太帅了！ 为什么是Weex？web开放包容、跨平台的特性，带来了互联网的繁荣，但它也有天生的缺点： 各浏览器厂商对JS标准的实现不同，导致了兼容性问题； 每次打开网页需要去远程下载，天然地慢一拍； DOM设计的缺陷，每次更新页面浏览器需要进行大量的操作。 在移动互联时代，第一个问题已不那么明显。后两个问题，无法根治。只能不断优化，对于第二个问题一般是采取减小请求数、缓存的机制；对于最后一个问题，现在比较流行的做法是Facebook最早在React中运用的虚拟DOM，还有通过Canvas图的方式。 而移动互联时代绝对主角——原生应用，它安装在本地，直接运行在系统中，具有高性能，那它有什么缺点呢？主要有二： 平台差异：同一产品一般至少需要开发web、android、ios三端，需要三波开发团队； 上线周期慢：一款应用上线一般需要一到几周，而这对时机稍纵即逝的互联网圈基本是不能容忍的。 如果有一个解决方案具有web跨平台、社区繁荣的优点，又兼备原生应用的高性能就好了。 今天的主角该出场了：Weex们。 闪亮登场Weex们，是社区中诞生的使用web开发过程开发端应用的技术。 通俗说，就是写一套web前端代码，编译成web、android、ios三端都可用的应用。 之所以加“们”，是因为除了Weex，社区还有现在最流行的React Native。 一探究竟我在原来学习Vue时做的项目中，选了个难度适中的来做weex重构。 效果 项目源码：weex-eleme 名存实亡的标签weex中，基本上可以说没有标签一说。 weex只支持一组内置的组件和在内置组件的基础上自定义的组件。 如果你要写一个weex，首先要做的就是把原来习惯的所有文本相关的标签换成&lt;text&gt;，图片相关的换成&lt;image&gt;。 CSS的差异weex中只支持单个类名，不允许使用关系选择器来定义类名。这一点官方文档里并没有说，但确是网友们踩坑总结出来的经验。 123456789// 单个类名，允许.a &#123; color: #fff; &#125;// 关系选择器，无效.a .b &#123; color: #000;&#125; 社区里有人成功地通过安装开发依赖和配置webpack的module选项使用了向sass这样的样式预处理器，也有说weex集成了常用的几种css预处理器，直接使用下面这样的标签写样式就行： 1&lt;style lang=&quot;sass&quot; scope&gt; 动态绑定类名在Vue中，我们通常像下面这样动态绑定类名： 12// 在weex中，类名可以成功加到渲染后的标签属性中，但样式不起作用&lt;div class=&quot;nav&quot; :class=&quot;&#123;active: flag&#125;&quot;&gt;&lt;/div&gt; 这是个比较奇怪的坑，最后找到一个解决方案： 12// 使用数组语法，数组里可以是三目运算或者函数调用&lt;div class=&quot;nav&quot; :class=&quot;[flag?&apos;active&apos;:&apos;&apos;]&quot;&gt;&lt;/div&gt; 元素内联weex中，&lt;text&gt;会被渲染成&lt;p&gt;，&lt;image&gt;会被渲染出&lt;figure&gt;，所有的display属性无法使用。如果你需要达到元素内联的效果，那你可以使用FlexBox： 12345678910111213 &lt;div class=&quot;wrapper&quot;&gt; &lt;text&gt;some text&lt;/text&gt; // image必须设置宽高 &lt;image style=&quot;width: 300;height: 300;border-width:2px;&quot; src=&quot;https://cn.vuejs.org/images/logo.png1 &gt; &lt;/image&gt; &lt;/div&gt;.wrapper &#123; flex-direction: row; &#125; scroller、list组件的坑weex提供了一个高效的适合显示长列表的&lt;list&gt;组件。它在加载包含大量图片的场景下威力就发挥出来了。 它初始时只会加载首屏的图片，在快滚到底部时再去请求新的图片。但，你必须给&lt;list&gt;（或者&lt;scroller&gt;）设置一个高度（水平使用时设置宽度）。 这个坑我是深有感受，没有给&lt;list&gt;设置高度，你滚动时&lt;list&gt;总是也到不了底部，下部的图片时不会加载的，而且scrollElement方法是不会奏效的。 如图所示，你设置的是wrapper的高度，wrapper不动，而content长度是超出wrapper的，你滚动时其实只是content在相对wrapper变化。只有这样，才能获取content相对于wrapper的位置，进行loadmore、scrollElement等事件或方法。 不然，wrapper的高度是被content撑开的，那它们就一起滚动了。 文本截断在官方的示例中，可以给&lt;text&gt;设置lines属性限制文本的行数： 其中有一个错误，就是lines设置在标签上是没有用的，而只有通过类名指定才会起效。he 然而，我电脑上并没有什么用！囧。 如果你的电脑也不起效，你可以像下面这样： 12345678910&lt;text class=&quot;text&quot;&gt; some text some text some text some text some text some text&lt;/text&gt;.text &#123; // 设置在css里，不一定起效 lines: 1 // 替代方案，官方示例渲染后的真实属性 -webkit-line-clapm: 1;&#125; 占坑bug常有，坑常有，来日填。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>weex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Albert Music穿上React新衣——记一次Vue项目重构经历]]></title>
    <url>%2F2018%2F02%2F28%2Freact-meet-vue%2F</url>
    <content type="text"><![CDATA[React的学习曲线高早有耳闻，但真的只有切身经历后才感受的深，也渐渐明白了Vue“渐进式框架”定位的含义。初学React时，只是使用了Ant Design搭积木式做了个新闻webApp，离掌握还差得远。于是，就有了这个React版Albert Music。 技术栈框架：React 16脚手架：Create-React-App路由：React Router 4数据管理：Redux 3数据请求：axios、jsonp优化：immutable.js、fastclick、AsyncComponent实现按需加载动画：React Transition Group语言：ES6预处理：Less 效果 脱坑要不要npm run eject？Create-React-App据说是为了优雅，将webpack配置相关的文件封装进了react-scripts包中。这有助于让开发者专注于前端代码，但却束缚力我们的手脚，不利于在脚手架的基础上进行扩展。我选择的是将配置文件暴露出来。 对webpack配置文件，主要进行三方面改造： 设置文件路径别名 使用less-loader 基于Express，通过devServer里before(app)函数设置数据接口 项目结构的选择以下两种项目结构或许都行：第一种，我现在使用的1234567891011121314151617181920|── src| |── api # 接口相关| |── base #基础组件| |── common # 通用文件| | |── fonts # 字体、图标| | |── images # 图片资源| | |── js # 函数| | |── style # 样式| |──components # 业务组件| |──store # Redux配置| | |── reducers # reducer文件夹| | | |── a.js # 子Reducer| | | |── b.js # 子Reducer| | | |── index.js # 合成所有子Reducer| | |── action-types.js # Action类型汇总| | |── actions.js # 定义action生成器、派发action| | |── index.js # 创建store| |──App.js # 根组件| |──index.js # 入口文件，根组件挂载| |──registerServiceWorker.js 第二种，Redux官方例子的项目目录 12345678910111213141516171819202122|── src| |──actions # Redux的Action文件夹| | |── actions.js # 定义action生成器、派发action| |── api # 接口相关| |── base #基础组件| |── common # 通用文件| | |── fonts # 字体、图标| | |── images # 图片资源| | |── js # 函数| | |── style # 样式| |──components # UI组件| |──constants # 常量| | |── action-types.js # Action类型汇总| |──containers # 容器组件| |──store # Redux配置| |── reducers # Redux的Reducer文件夹| | |── a.js # 子Reducer| | |── b.js # 子Reducer| | |── index.js # 合成所有子Reducer| |──App.js # 根组件| |──index.js # 入口文件，根组件挂载，创建store| |──registerServiceWorker.js 这两种项目结构主要有两点差别： 第一种统一将Redux放在src下，而第二种将Redux拆分后各部分直接放在src下 后者将使用了Redux的组件显式拆分成UI组件和容器组件，层次清晰 第一种有着明显的Vue全家桶开发痕迹，但整个技术栈的层次清晰。第二种更适合React全家桶的开发模式，显式将使用了Redux的组件拆分，这点有着明显的优点。 或许，结合两者的优点是更好的选择：将Redux相关的写到一个文件，显式写出容器组件 路由配置在Vue中，我们习惯于通过一个配置文件t统一管理路由，像这样： 12345678910111213141516171819export default new Router(&#123; mode: 'history', routes: [ &#123; path: '/', redirect: '/recommend' &#125;, &#123; path: '/recommend', component: Recommend, children: [ &#123; path: ':id', component: Disc &#125; ] &#125; ]&#125;) 而在React中，路由也是组件。需要像下面这样把根组件App改造成一个Router组件。至于子路由，可以直接在这个文件配置，也可以在需要的组件下再嵌套 123456789101112131415161718192021// App.jsclass App extends Component &#123; render() &#123; return ( &lt;Router&gt; &lt;Switch&gt; &lt;Route path="/" exact render=&#123;() =&gt; ( &lt;Redirect to="/recommend" /&gt; )&#125; /&gt; &lt;Route path="/recommend" component=&#123;Recommend&#125; /&gt; &lt;/Switch&gt; &lt;/Router&gt; ); &#125;&#125;// Recommend.jsexport const Recommend = (&#123;match&#125;) =&gt; (&#123; &lt;Route path=&#123;`$&#123;match.url&#125;/:Id`&#125; component=&#123;SingerDetail&#125; /&gt; &lt;Route exact path=&#123;match.url&#125; render=&#123;() =&gt; SomeComp /&gt;&#125;) 监听数据变化这个大概是两个框架的最大差别了。 在Vue中，我们可以很方便地设置计算属性和watch来处理数据变化时的逻辑。 在React中，为达到同样的目的，我使用了shouldComponentUpdate()、componentWillReceiveProps()这两个钩子函数。123456789101112shouldComponentUpdate(nextProps, nextState) &#123; // 监测state变化 if (nextStates.foo !== nextState.foo) &#123; // doSomething &#125;&#125;componentWillReceiveProps(nextProps) &#123; // 监测props变化 if (nextProps.baz !== nextProps.baz) &#123; // doSomething &#125;&#125; 列表和条件渲染在Vue中，列表和条件渲染可以方便的分别通过v-for、v-if或者v-show来实现。 在React中，我们需要采用jsx的方式： 12345678910111213// 列表渲染const listItems = &#123; // key是必须的，有助于提升重新渲染时的性能 array.map((item, index) =&gt; ( &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;/li&gt; &#125;ReactDOM.render( &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;, document.getElementById('root'));// 条件渲染const UserCenter = this.props.isLogIn ? : &lt;LogOut /&gt; : &lt;LogIn /&gt; 数据管理Vue有Vuex，React对应着Redux。不过，Redux比Vuex使用起来复杂得多。 四句话就能说请Vuex的用法： 1、设置state对象：里面包含所有需要全局管理的数据2、设置mutation-types：一个数据对应一个类型，如：1export const SET_DATA='SET_DATA' 3、设置mutation：一个mutation改变一个state里的数据，仅赋值4、设置action：每个action可包含复杂逻辑、异步请求，通过commit提交mutation一个或多个请求 Redux就复杂多了，又是中间件、又是react-redux，不过我经过多天的爬坑也可提炼个基本套路： 1、设置action-types：一个数据对应一个类型，如：1export const SET_DATA='SET_DATA' 2、编写Actions.js：一个数据对应一个Action生成器，为每个Action编写一个函数派发它，最后编写派发多个action的函数3、编写Reducer文件夹：index.js，负责合成子Reducer，并提供state里所有数据的接口；若干个子Reducer，为接受每个Action更新state里的对应数据4、设置store：传入将合成后的Reducer、中间件5、拆分组件：将需要使用全局数据的组件用一个空组件包裹，将Redux的数据接口提供给mapStateToProps，actions提供给mapDispatchToProps，通过connect将外层组件变为容器组件，给内层组件传入属性、方法 终于赶在了3月前把项目重构完，也算是把React全家桶掌握了。下一站，Weex！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遇见webpack]]></title>
    <url>%2F2018%2F01%2F30%2Fhello-webpack%2F</url>
    <content type="text"><![CDATA[Webpack很早就接触了，但以前一直都是跟着脚手架跑跑命令行。配置文件也不算陌生，但一直也没深究。毕竟webpack配置工程师可是稀缺人才啊！昨天在微博上看到有人把阮一峰的webpack-demos教程更新到了3.1，但只有英文版。我索性做个中文文档，趁此再系统学习学习。 这里收集了一些Webpack的简单demo。 我旨在通过简明的方式来写这些demo。跟着它们，你将轻松地学习这一强大的工具。 如何使用首先，全局安装Webpack and webpack-dev-server 1$ npm i -g webpack webpack-dev-server 之后，复制这个库到本地。 1$ git clone https://github.com/ruanyf/webpack-demos.git 接着，安装所有依赖。 12$ cd webpack-demos$ npm install 现在，按顺序在这些以demo开头的目录下运行源文件。像这样： 12$ cd demo01$ npm run dev 如果以上命令没有自动打开你的浏览器，恐怕你需要自行访问http://127.0.0.1:8080 。 前言：Webpack是什么Webpack是一个为浏览器构建JavaScript模块脚本的前端工具。 它用起来和Browserify很像，但功能更强大。 123$ browserify main.js &gt; bundle.js# 等同于$ webpack main.js bundle.js Webpack需要一个叫做webpack.config.js配置文件，而它其实就是一个CommonJS文件。 1234567// webpack.config.jsmodule.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;&#125;; 在配置好webpack.config.js文件后，你能在没有任何参数的情况下启动webpack。 1$ webpack 下面这些命令行选项你需要知道： webpack – 开发环境下打包 webpack -p – 生产环境下打包 (压缩) webpack --watch – 监听文件变化并自动打包 webpack -d – 包含source maps（译注：source maps为源码转化后的位置信息文件） webpack --colors – 生成带有颜色的打包输出信息 你可以像下面这样在你的package.json文件中自定义scripts项。 123456789// package.json&#123; // ... "scripts": &#123; "dev": "webpack-dev-server --devtool eval --progress --colors", "deploy": "NODE_ENV=production webpack -p" &#125;, // ...&#125; 目录 入口文件 多个入口文件 Babel-loader CSS-loader Image loader CSS模块 UglifyJs插件 HTML Webpack插件和Open Browser Webpack插件 环境标志 代码分割 使用bundle-loader进行代码分割 共同块 依赖块 暴露全局变量 React router Demo01: 入口文件 (源码)Webpack读取入口文件来生成bundle.js。 例如，main.js就是这样一个入口文件。 12// main.jsdocument.write('&lt;h1&gt;Hello World&lt;/h1&gt;'); index.html 12345&lt;html&gt; &lt;body&gt; &lt;script type="text/javascript" src="bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Webpack按照webpack.config.js里的配置来生成bundle.js。 1234567// webpack.config.jsmodule.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;&#125;; 启动webpack server，访问http://127.0.0.1:8080 。 12$ cd demo01$ npm run dev Demo02: 多个入口文件 (源码)有多个入口文件也是允许的。对于有多个不同入口文件的多页应用来说这会很有用。 12345// main1.jsdocument.write('&lt;h1&gt;Hello World&lt;/h1&gt;');// main2.jsdocument.write('&lt;h2&gt;Hello Webpack&lt;/h2&gt;'); index.html 123456&lt;html&gt; &lt;body&gt; &lt;script src="bundle1.js"&gt;&lt;/script&gt; &lt;script src="bundle2.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; webpack.config.js 123456789module.exports = &#123; entry: &#123; bundle1: './main1.js', bundle2: './main2.js' &#125;, output: &#123; filename: '[name].js' &#125;&#125;; Demo03: Babel-loader (源码)xxx-loader(more info)是在Webpack打包前转换项目里资源文件的预处理器。 例如，Babel-loader能够将JSX/ES6文件转换成普通的JS文件，之后，Webpack再打包它们。Webpack的官方文档里列出了完整的loaders。 main.jsx是一个JSX文件。 12345678// main.jsxconst React = require('react');const ReactDOM = require('react-dom');ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.querySelector('#wrapper')); index.html 123456&lt;html&gt; &lt;body&gt; &lt;div id="wrapper"&gt;&lt;/div&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; webpack.config.js 1234567891011121314151617181920module.exports = &#123; entry: './main.jsx', output: &#123; filename: 'bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\.jsx?$/, exclude: /node_modules/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['es2015', 'react'] &#125; &#125; &#125; ] &#125;&#125;; 以上代码在使用babel-loader时，需要Babel的预设插件babel-preset-es2015和babel-preset-react来转换ES6和React。 Demo04: CSS-loader (源码)Webpack允许你在JS文件中包含CSS，它将通过CSS-loader来预处理这些CSS。 main.js 1require('./app.css'); app.css 123body &#123; background-color: blue;&#125; index.html 12345678&lt;html&gt; &lt;head&gt; &lt;script type="text/javascript" src="bundle.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; webpack.config.js 1234567891011121314module.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;, module: &#123; rules:[ &#123; test: /\.css$/, use: [ 'style-loader', 'css-loader' ] &#125;, ] &#125;&#125;; 注意，你需要两个loader来转换CSS文件。一个是CSS-loader来读CSS文件，另一个是Style-loader来将&lt;style&gt;标签插入HTML页面中。 之后，启动webpack server。 12$ cd demo04$ npm run dev 其实，Webpack将内联样式表插入了index.html。 12345678&lt;head&gt; &lt;script type="text/javascript" src="bundle.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; body &#123; background-color: blue; &#125; &lt;/style&gt;&lt;/head&gt; Demo05: Image loader (源码)Webpack也能在JS文件包含图片。 main.js 1234567var img1 = document.createElement("img");img1.src = require("./small.png");document.body.appendChild(img1);var img2 = document.createElement("img");img2.src = require("./big.png");document.body.appendChild(img2); index.html 12345&lt;html&gt; &lt;body&gt; &lt;script type="text/javascript" src="bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; webpack.config.js 123456789101112131415161718192021module.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;, module: &#123; rules:[ &#123; test: /\.(png|jpg)$/, use: [ &#123; loader: 'url-loader', options: &#123; limit: 8192 &#125; &#125; ] &#125; ] &#125;&#125;; url-loader将图片文件转换成&lt;img&gt;标签。如果图片尺寸小于8192字节，它会被转换成Data URL（译注：Data URL是将图片用base64编码后的字符串）；否则，它将转换成普通URL。 在启动server后，small.png和big.png分别将有以下URL： 12&lt;img src="data:image/png;base64,iVBOR...uQmCC"&gt;&lt;img src="4853ca667a2b8b8844eb2693ac1b2578.png"&gt; Demo06: CSS模块 (源码)带查询参数modules的css-loader将CSS文件变为一个CSS模块，模块里的CSS都是局部定义的。你可以使用:global(selector)(详情)将CSS变为全局的。 index.html 12345678&lt;html&gt;&lt;body&gt; &lt;h1 class="h1"&gt;Hello World&lt;/h1&gt; &lt;h2 class="h2"&gt;Hello Webpack&lt;/h2&gt; &lt;div id="example"&gt;&lt;/div&gt; &lt;script src="./bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; app.css 123456789/* local scope */.h1 &#123; color:red;&#125;/* global scope */:global(.h2) &#123; color: blue;&#125; main.jsx 1234567891011var React = require('react');var ReactDOM = require('react-dom');var style = require('./app.css');ReactDOM.render( &lt;div&gt; &lt;h1 className=&#123;style.h1&#125;&gt;Hello World&lt;/h1&gt; &lt;h2 className="h2"&gt;Hello Webpack&lt;/h2&gt; &lt;/div&gt;, document.getElementById('example')); webpack.config.js 12345678910111213141516171819202122232425262728293031323334module.exports = &#123; entry: './main.jsx', output: &#123; filename: 'bundle.js' &#125;, module: &#123; rules:[ &#123; test: /\.js[x]?$/, exclude: /node_modules/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['es2015', 'react'] &#125; &#125; &#125;, &#123; test: /\.css$/, use: [ &#123; loader: 'style-loader' &#125;, &#123; loader: 'css-loader', options: &#123; modules: true &#125; &#125; ] &#125; ] &#125;&#125;; 启动webpack server。 12$ cd demo06$ npm run dev 访问http://127.0.0.1:8080 ，你将发现只有第二个h1是红色的，因为它的CSS是局部的；而两个h2都是蓝色的，因为它的CSS是全局的。 Demo07: UglifyJs插件 (源码)Webpack通过插件体系来扩展它的功能。例如，UglifyJs插件能够压缩输出(bundle.js)的JS代码。 main.js 123var longVariableName = 'Hello';longVariableName += ' World';document.write('&lt;h1&gt;' + longVariableName + '&lt;/h1&gt;'); index.html 12345&lt;html&gt;&lt;body&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; webpack.config.js 123456789101112var webpack = require('webpack');var UglifyJsPlugin = require('uglifyjs-webpack-plugin');module.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;, plugins: [ new UglifyJsPlugin() ]&#125;; 在启动server之后，main.js将会被压缩成下面这样。 1var o="Hello";o+=" World",document.write("&lt;h1&gt;"+o+"&lt;/h1&gt;") Demo08: HTML Webpack插件和Open Browser Webpack插件 (源码)这个demo像你演示如何载入第三方插件。 html-webpack-plugin能够为你创建index.html，而open-browser-webpack-plugin当Webpack载入时能够打开一个新的浏览器标签页。 main.js 1document.write('&lt;h1&gt;Hello World&lt;/h1&gt;'); webpack.config.js 123456789101112131415161718var HtmlwebpackPlugin = require('html-webpack-plugin');var OpenBrowserPlugin = require('open-browser-webpack-plugin');module.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;, plugins: [ new HtmlwebpackPlugin(&#123; title: 'Webpack-demos', filename: 'index.html' &#125;), new OpenBrowserPlugin(&#123; url: 'http://localhost:8080' &#125;) ]&#125;; 启动server。 12$ cd demo08$ npm run dev 现在你不必再手写index.html了，也不必再自己打开浏览器了。Webpack将会为你做这些事。 Demo09: 环境标志 (源码)你可以通过环境标志让某些代码仅在开发环境下有效。 main.js 12345document.write('&lt;h1&gt;Hello World&lt;/h1&gt;');if (__DEV__) &#123; document.write(new Date());&#125; index.html 12345&lt;html&gt;&lt;body&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; webpack.config.js 12345678910111213var webpack = require('webpack');var devFlagPlugin = new webpack.DefinePlugin(&#123; __DEV__: JSON.stringify(JSON.parse(process.env.DEBUG || 'false'))&#125;);module.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;, plugins: [devFlagPlugin]&#125;; 现在把环境变量传递给webpack。打开demo09/package.json，你应该会发现scripts变成了这样： 12345678// package.json&#123; // ... "scripts": &#123; "dev": "cross-env DEBUG=true webpack-dev-server --open", &#125;, // ...&#125; 启动server。 12$ cd demo09$ npm run dev Demo10: 代码分割 (源码)对于大型web应用来说，将所有的代码写进一个文件效率会很低。Webpack允许你将大的JS文件拆分成若干个小的代码块（chunk)。尤其在一些代码块仅在某些情况下才使用时，这些代码块应该按需加载。 Webpack使用require.ensure去定义一个拆分点(官方文档)。 1234567// main.jsrequire.ensure(['./a'], function (require) &#123; var content = require('./a'); document.open(); document.write('&lt;h1&gt;' + content + '&lt;/h1&gt;'); document.close();&#125;); require.ensure告诉Webpack./a.js应该从bundle.js中分离出来，并打包成一个单独的块文件。 12// a.jsmodule.exports = 'Hello World'; 现在Webpack将会关心依赖、输出文件和运行时环境。而你不必往index.html和webpack.config.js里添加任何东西。 12345&lt;html&gt; &lt;body&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; webpack.config.js 123456module.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;&#125;; 启动server。 12$ cd demo10$ npm run dev 表面上，你不会感觉到任何变化。然而，Webpack实际上将main.js和a.js打包成了不同的块（bundle.js和0.bundle.js)，并且在需要时从bundle.js载入0.bundle.js。 Demo11: 使用bundle-loader进行代码分割 (源码)另一种代码分割的方式是使用bundle-loader。 123456789101112// main.js// 现在导入请求a.js，将它打包进另一个文件var load = require('bundle-loader!./a.js');// 等待a.js载入并获得它导出的内容// 你需要异步等待它load(function(file) &#123; document.open(); document.write('&lt;h1&gt;' + file + '&lt;/h1&gt;'); document.close();&#125;); require(&#39;bundle-loader!./a.js&#39;)告诉Webpack从另一个块中载入a.js。 现在Webpack将会把main.js打包成bundle.js，把a.js打包成0.bundle.js。 Demo12: 共同块 (源码)当多个脚本有共同的代码块时，你可以用CommonsChunkPlugin将它们导入一个单独的文件，这有助于浏览器缓存以及节省带宽。 1234567891011121314151617// main1.jsxvar React = require('react');var ReactDOM = require('react-dom');ReactDOM.render( &lt;h1&gt;Hello World&lt;/h1&gt;, document.getElementById('a'));// main2.jsxvar React = require('react');var ReactDOM = require('react-dom');ReactDOM.render( &lt;h2&gt;Hello Webpack&lt;/h2&gt;, document.getElementById('b')); index.html 123456789&lt;html&gt; &lt;body&gt; &lt;div id="a"&gt;&lt;/div&gt; &lt;div id="b"&gt;&lt;/div&gt; &lt;script src="commons.js"&gt;&lt;/script&gt; &lt;script src="bundle1.js"&gt;&lt;/script&gt; &lt;script src="bundle2.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 以上的commons.js是main1.jsx和main2.jsx的共同代码块。正如所料，commons.js包含了react和react-dom。 webpack.config.js 12345678910111213141516171819202122232425262728293031323334var webpack = require('webpack');module.exports = &#123; entry: &#123; bundle1: './main1.jsx', bundle2: './main2.jsx' &#125;, output: &#123; filename: '[name].js' &#125;, module: &#123; rules:[ &#123; test: /\.js[x]?$/, exclude: /node_modules/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['es2015', 'react'] &#125; &#125; &#125;, ] &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: "commons", // （共同块的名称） filename: "commons.js", // （共同块的文件名） &#125;) ]&#125; Demo13: 依赖块 (源码)通过CommonsChunkPlugin，你也能将依赖库从脚本中导入一个单独的文件。 main.js 12var $ = require('jquery');$('h1').text('Hello World'); index.html 1234567&lt;html&gt; &lt;body&gt; &lt;h1&gt;&lt;/h1&gt; &lt;script src="vendor.js"&gt;&lt;/script&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; webpack.config.js 1234567891011121314151617var webpack = require('webpack');module.exports = &#123; entry: &#123; app: './main.js', vendor: ['jquery'], &#125;, output: &#123; filename: 'bundle.js' &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', filename: 'vendor.js' &#125;) ]&#125;; 上面的代码中，entry.vendor: [&#39;jquery&#39;]告诉Webpack应该将jquery包含在共同的代码块vendor.js中。 如果你想一个模块变量全局生效，例如不通过require(&quot;jquery&quot;)就在每一个模块中使用$和jQuery。你应该使用ProvidePlugin (官方文档)，它能不用特意引入而自动载入模块。 123456789101112131415161718192021// main.js$('h1').text('Hello World');// webpack.config.jsvar webpack = require('webpack');module.exports = &#123; entry: &#123; app: './main.js' &#125;, output: &#123; filename: 'bundle.js' &#125;, plugins: [ new webpack.ProvidePlugin(&#123; $: 'jquery', jQuery: 'jquery' &#125;) ]&#125;; 当然，在这个例子中，你应该自己全局导入jquery.js。 Demo14: 暴露全局变量 (源码)If you want to use some global variables, and don’t want to include them in the Webpack bundle, you can enable externals field in webpack.config.js (official document). 例如，我们有一个data.js。 12// data.jsvar data = 'Hello World'; index.html 123456&lt;html&gt; &lt;body&gt; &lt;script src="data.js"&gt;&lt;/script&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 注意，Webpack只会生成bundle.js，而不会生成data.js。 我们可以将data暴露为一个全局变量。 12345678910111213141516171819202122232425// webpack.config.jsmodule.exports = &#123; entry: './main.jsx', output: &#123; filename: 'bundle.js' &#125;, module: &#123; rules:[ &#123; test: /\.js[x]?$/, exclude: /node_modules/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['es2015', 'react'] &#125; &#125; &#125;, ] &#125;, externals: &#123; // 通过require('data')导入data.js即可全局生效 'data': 'data' &#125;&#125;; 现在，你在脚本里像模块变量一样导入data，但实际上它是一个全局变量。 123456789// main.jsxvar data = require('data');var React = require('react');var ReactDOM = require('react-dom');ReactDOM.render( &lt;h1&gt;&#123;data&#125;&lt;/h1&gt;, document.body); 你也能将react和react-dom放入externals里，这将极大地减小bundle.js的编译时间和大小。 Demo15: React router (源码)这个demo使用webpack来构建React-router的官方例子。 想象一个有着仪表板、收信箱和日历的小应用。 12345678910111213141516171819+---------------------------------------------------------+| +---------+ +-------+ +--------+ || |Dashboard| | Inbox | |Calendar| Logged in as Jane || +---------+ +-------+ +--------+ |+---------------------------------------------------------+| || Dashboard || || || +---------------------+ +----------------------+ || | | | | || | + + | +---------&gt; | || | | | | | | || | | + | | +-------------&gt; | || | | | + | | | | || | | | | | | | | || +-+---+----+-----+----+ +----------------------+ || |+---------------------------------------------------------+ webpack.config.js 123456789101112131415161718192021222324module.exports = &#123; entry: './index.js', output: &#123; filename: 'bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\.css$/, use: [ 'style-loader', 'css-loader' ] &#125;, &#123; test: /\.jsx?$/, exclude: /node_modules/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['es2015', 'react'] &#125; &#125; &#125;, ] &#125;&#125;; index.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import React from 'react';import &#123; render &#125; from 'react-dom';import &#123; BrowserRouter, Switch, Route, Link &#125; from 'react-router-dom';import './app.css';class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;header&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to="/app"&gt;Dashboard&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to="/inbox"&gt;Inbox&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to="/calendar"&gt;Calendar&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; Logged in as Jane &lt;/header&gt; &lt;main&gt; &lt;Switch&gt; &lt;Route exact path="/" component=&#123;Dashboard&#125;/&gt; &lt;Route path="/app" component=&#123;Dashboard&#125;/&gt; &lt;Route path="/inbox" component=&#123;Inbox&#125;/&gt; &lt;Route path="/calendar" component=&#123;Calendar&#125;/&gt; &lt;Route path="*" component=&#123;Dashboard&#125;/&gt; &lt;/Switch&gt; &lt;/main&gt; &lt;/div&gt; ); &#125;&#125;;class Dashboard extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;p&gt;Dashboard&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;;class Inbox extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;p&gt;Inbox&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;;class Calendar extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;p&gt;Calendar&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;;render(( &lt;BrowserRouter&gt; &lt;Route path="/" component=&#123;App&#125; /&gt; &lt;/BrowserRouter&gt;), document.querySelector('#app')); index.html 123456&lt;html&gt; &lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;script src="/bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/htmL&gt; 启动server。 12$ cd demo15$ npm run dev 有用的链接 Webpack docs webpack-howto, by Pete Hunt SurviveJS Webpack book, by Juho Vepsäläinen Diving into Webpack, by Web Design Weekly Webpack and React is awesome, by Christian Alfoni Browserify vs Webpack, by Cory House 许可证MIT]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[indexOf()引发的血案——引用类型初探]]></title>
    <url>%2F2018%2F01%2F23%2Funderstand-reference-type%2F</url>
    <content type="text"><![CDATA[最近，又开始学JS了。JS大概永远也学不完吧！ 初学时，选择的是“犀牛书”，它被称为JS程序员心中的“圣经”。被称为“经”，我想是有原因的。这本书块头很大，语言有些晦涩，看得我晕头转向（上次这种感觉还是看《数据结构与算法分析》时），但我竟然啃（fan）下（guo）来（yi）了（bian）。我想很大的原因可能是当初淘宝团队在翻译时采用了接近直译的方式。 后来，发现越来越多的人看的是“红宝书”，那我也不能落下啊！看了几章，相见恨晚。它的语言很对中国人的味儿，就像一位网友说的，读它就像读一篇篇的博客。而它，又不失深度。 案发当我看到第五章引用类型时，被眼前的一幕震惊了： var person = { name: "Nicholas"}; var people = [{ name: "Nicholas"}; var morePeople = [person]; alert(people.indexOf(person)); //-1 alert(morePeople.indexOf(person)); //0 为什么在people中会找不到person，而在morePeople中却可以？ 案情分析1号嫌疑人：印错我买的书虽不一定是正版，但错这么离谱好像不太可能。 无作案动机，排除！ 2号嫌疑人：indexOf()查找时严格相等的条件搜便案发现场，没发现“凶器”类型转换啊？ 有不在场证明，排除！ 僵掉了呀！ 3号嫌疑人：引用类型人脏具获，束手就擒吧： var person = { name: "Nicholas"}; //person是对象{ name: "Nicholas"}的引用A，是一个对象指针 var people = [{ name: "Nicholas"}; //people是一个包含对象{ name: "Nicholas"}的另一个引用B的数组 var morePeople = [person]; //morePeople 是一个包含对象{ name: "Nicholas"}的引用A的数组 alert(people.indexOf(person)); //-1，people中只有引用B，没有引用A alert(morePeople.indexOf(person)); //0，people中有引用A 结案解决每一个问题，都是对自己的查缺补漏。真好！ 基础，基础，基础！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>引用类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F01%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[我在想，你善待世界，大概世界也会善待你吧！ 捣鼓一个星期，总算是把博客搭得差不多了。搭博客的过程简直就是一个踩坑之旅。 博客框架的选择开始之前，在知乎逛了逛，发现搭博客/网站的框架主流的有这么三个： WordPress早闻大名，但是PHP平台的，果断放弃 Hexo基于node，知乎很多人推荐，其中不乏像尤雨溪这样的大神 Hugo基于Go，这一两年火起来的，Github上的star数直逼Hexo。它的定位很是高远，要做世上最快的静态网站生成框架。有网友做过对比说，Hugo的编译速度可以比Hexo快到几十倍 毫无疑问，基于node的Hexo是对搞前端的同学来说最好的选择。 主题重构选主题时的发现，再一次证明了我的选择。 我发现Hexo社区有一款非常棒的主题——next。简直可以用excellent来形容，它好倒不在UI上，那怎么厉害了？ 受欢迎：它在Github上有近1万1的star 生态好：很多网友贡献代码，使得next的功能强大，有详细的文档 配置性好：尽管集成了那么多功能，但通过配置一个config文件，一步搞定 扩展性高：通过swig模板语言编写，方便维护和扩展 可是我对它的UI并不太喜欢，感觉太老土了。于是，我站在巨人的肩上，开始了主题重构。 最后的效果，就是呈现在各位面前的。 我给它取了个名字，叫Memory。 绝地求生“吃鸡”游戏最近很火，我也来蹭下热度。～(￣▽￣～)~ 判断当前页面要实现我的设计，一个首要问题就是判断当前页面的状态，是主页，文章，归档？最后，我在Hexo官方文档找到了答案，嗯，辅助函数：is_home()：检查是否为首页is_post()：检查是否为文章is_archive()：检查是否为归档页… 这些条件函数配合swig之类的模板引擎就能写出你想要的页面逻辑. so nice! 读取页面信息要用siwg写出内容响应式的页面，读取每个页面或文章的具体属性是绕不开的问题。 理论上，读取文章属性，post这个变量最合适不过了。可是，事情总不会那么顺利。 next主题的文档布局是一个大的类名为container的div包裹了header、main、footer三个部分。源码里，文章页的文章内容是包裹在main里面的，而我的需求是将文章的meta信息在header部分显示，而header和main在源码中是在不同模块里实现的，这时用post变量就会出现读取不到值的现象。 这时，又时官方文档拯救了我！我发现，page和post这两个变量有着剪不断理还乱的联系。那就试试page变量！ Did it! 再配合着front-matter，那feel倍爽儿啊！！！可以“从心所欲”了！ 终极bug该来的总会来的。 最后重构的事基本完成了，要部署到Github上了，当我在线访问时，发现我的页面竟然是这样的： Are you kidding me?！！！ 我在本地启server预览时可是OK的！？怎么会public文件夹里的东西和本地server访问的不一样？见鬼了。一套代码，两种编译结果！？ 为此，苦苦挣扎了一天，各种百度，各种看文档，各种问师兄，最后还到hexo仓库下开了个issue。 过了几小时，发现并没有人鸟我。唉，要放弃了。滚去啃转头书了。 越啃越困。。。唉。。。 就在这时，我突然想起了官方文档里提到，对于服务器： 12$ hexo server // 动态监听文件变化$ hexo server -s // 只访问public文件夹里的资源 而对于生成器： 12$ hexo generate // 生成静态文件$ hexo generate -w // 监视文件变动并立即重新生成静态文件 既然hexo s和hexo g的编译结果不一样，而hexo g -w和hexo s同样是动态编译，是不是就可以生成想要的结果呢？ Did it! 写在最后Hello World，大概是每人程序员写的第一个程序了。记得去年阿里18周年年会时，黄龙外就挂着“Hello World”的巨幅喷绘。 我在想，你善待世界，大概世界也会善待你吧！ 这应该算是我第一篇严格意义上的博客了，写博客是进入一个新世界，每一天、每一段旅程都是进入一个新世界。 我常常会跟女朋友讲我在学的、在做的东西，我总试着用最通俗的语言让她也能明白。前段时间，看了一位网友写自己理解闭包的博客，里面有句话让我印象深刻：“如果一个概念你不能用一两句话说明白，那你就是没有真正地懂。” 真是精辟！于是，我计划着写算是一个系列吧，用最通俗、精练的话去总结一些前端的基础问题。一来总结的过程是对自己的提高，为今年的校招做准备，二来要是能对谁有一点帮助那就意外的收获了。 这个系列或许可以叫“前端那些事儿”之类的吧，哈哈！当年明月通俗幽默讲明史，我为何不可通俗幽默说前端呢？ “开机，启动，接入！” 既然选择了远方，便只顾风雨兼程——汪国真]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初次见面，请多指教]]></title>
    <url>%2F2018%2F01%2F18%2Fnice-to-meet-you%2F</url>
    <content type="text"><![CDATA[大家好，你们可以叫我萧文，也可以叫我Albert。 萧文，这个名字和我颇有渊源，小时候就差点叫了这个名字。我在想，以后要是进了哪个厂，我的花名就叫萧文了。 关于我的英文名有个小故事：高中时，英语老师以抽签的方式给每人都取了个英文名，还告诉我Albert有“聪明、高贵、人类的守护者”的意思，我也就阴差阳错地承担起了守护人类、拯救地球的责任。哈哈！ 高考填志愿时，凭着自己多年来练就的“3秒修好掉链条的单车”的天赋，我报了机械专业，自此离拯救地球的道路远走远远。还好，当时学了个C语言程序设计。 本科毕业后，来杭州读了个小硕。没错，还是机械╯▂╰。可是我读的专业是机械和计算机的结合呀，哈哈哈！ 众多CS方向中，我选择了前端。为啥？喜欢呗！我发现这是一个可以将我所有的兴趣都结合起来的。。。 什么呢？ 嗯，事业！！！ 前端太好玩了！什么设计、图形、webGL、动画、游戏、业务、数据可视化、算法，各种新工具、新技术，应有尽有。 有句话叫做：“有人的地方就有江湖。”我想说：“未来的时代，有人的地方就有前端。” 扯了这么多，该滚去学习了。 还有很多知识要学，还有好多代码要写，长路漫漫，任重道远。。。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
